{"/channel/intro":{"title":"Intro","data":{}},"/coroutine-context/coroutine-context-types-features-and-uml":{"title":"Coroutine Context Types Features and Uml","data":{"coroutinecontext-의-종류-특징-uml#CoroutineContext 의 종류, 특징, UML":"","coroutinecontext-interface#CoroutineContext Interface":"","emptycoroutinecontext-element-combinedcontext-key#EmptyCoroutineContext, Element, CombinedContext, Key":"","대표적인-coroutinecontext-의-종류들#대표적인 CoroutineContext 의 종류들":"UML 과 함께 정리","coroutinecontext-의-연산자-오버로딩#CoroutineContext 의 연산자 오버로딩":""}},"/coroutine-context/intro":{"title":"Intro","data":{}},"/coroutine-context/what-is-coroutine-context":{"title":"What Is Coroutine Context","data":{"coroutinecontext#CoroutineContext":"자바에서는 Thread 에서 공유할 데이터를 ThreadLocal 을 통해 공유합니다. 하지만 suspend 함수에서 코루틴 기반의 연산을 할 경우에는 이것이 불가능합니다. 코틀린에서는 코틀린의 코루틴에서 사용되는 하나의 데이터 문맥을 CoroutineContext 라고 부릅니다.그리고 이 CoroutineContext 는 Java 의 ThreadLocal 처럼 전역적으로 공유하는 것이 아니라 어떤 코루틴에서 생성했는지 여부 등에 따라서 지역적인 특성을 가집니다. 개인적으로는 코틀린의 코루틴을 처음 접할 때 이런 점이 Java 보다는 더 매력적으로 느껴졌던 것 같습니다.","threadlocal#ThreadLocal":"Kotlin 의 코루틴은 runBlocking 을 사용할 경우를 제외하고는  Java 의 ThreadLocal 을 이용해 스레드 레벨에서의 Context 공유는 불가능합니다. 대신 ThreadLocal 을 CoroutineContext 를 통해 표현한 코틀린 버전의 ThreadLocalElement 라는 CoroutineContext 객체가 있기는 합니다.e.g.\npackage io.chagchagchag.demo.kotlin_coroutine.coroutine_context\r\n\r\nimport io.chagchagchag.demo.kotlin_coroutine.helper.logger\r\nimport kotlinx.coroutines.Dispatchers\r\nimport kotlinx.coroutines.launch\r\nimport kotlinx.coroutines.runBlocking\r\n\r\n\r\nfun main(){\r\n  val log = logger()\r\n  \r\n  val isGreen = ThreadLocal<String>()\r\n  isGreen.set(\"Yes\")\r\n\r\n  runBlocking {\r\n    // 1)\r\n    log.info(\"현재 스레드 = {}\", Thread.currentThread().name)\r\n    log.info(\"isGreen == {}\", isGreen.get())\r\n    assert(isGreen.get() != null)\r\n\r\n    // 2)\r\n    launch (Dispatchers.IO){\r\n      log.info(\"현재 스레드 = {}\", Thread.currentThread().name)\r\n      log.info(\"isGreen = {}\", isGreen.get())\r\n      assert(isGreen.get() == null)\r\n    }\r\n  }\r\n  \r\n}\n출력결과\n20:34:55.017 [main] INFO io.chagchagchag.demo.kotlin_coroutine.helper.LoggerDump -- 현재 스레드 = main\r\n20:34:55.021 [main] INFO io.chagchagchag.demo.kotlin_coroutine.helper.LoggerDump -- isGreen == Yes\r\n20:34:55.037 [DefaultDispatcher-worker-1] INFO io.chagchagchag.demo.kotlin_coroutine.helper.LoggerDump -- 현재 스레드 = DefaultDispatcher-worker-1\r\n20:34:55.038 [DefaultDispatcher-worker-1] INFO io.chagchagchag.demo.kotlin_coroutine.helper.LoggerDump -- isGreen = null\n1) 과 2) 에서 각각 사용된 스레드가 다르다는 것을 확인 가능합니다.1)\n1) 에서 호출한 결과는 ThreadLocal 의 변수를 제대로 가져옵니다.\n그리고 현재 스레드의 이름을 출력해본 결과 main 으로 나타납니다.\nrunBlocking 이라는 코루틴 빌더는 main 스레드에서 실행되기 때문에 ThreadLocal 을 사용가능하고, main 스레드에서 실행할 수 있습니다.\n하지만 블로킹 방식이라는 점에 주의해야 합니다.\n2)\n2) 에서 호출한 결과는 main 클래스에서 선언한 ThreadLocal 변수의 값을 가져오지 못합니다.\nmain 스레드에서 실행되는 것이 아니기 때문입니다.\nlaunch, async 같은 suspend 함수들은 main 스레드에서 실행되지 않고 코루틴에서 실행됩니다.\n코루틴은 내부적으로 다른 스레드에서 실행되고 코루틴 자신이 실행될 스레드 역시 CoroutineDispatcher 에 의해 바뀔 때도 있습니다. 따라서 ThreadLocal 변수를 공유하는 것이 불가능에 가깝습니다.","suspend-함수-내에서-coroutinecontext-를-어떻게-접근하나요#suspend 함수 내에서 CoroutineContext 를 어떻게 접근하나요?":"suspend 키워드가 적용된 함수 내에서는 coroutineContext 라는 변수에 접근 가능합니다.\npackage io.chagchagchag.demo.kotlin_coroutine.coroutine_context\r\n\r\nimport io.chagchagchag.demo.kotlin_coroutine.helper.logger\r\nimport kotlinx.coroutines.runBlocking\r\nimport kotlin.coroutines.coroutineContext\r\nimport kotlin.coroutines.resume\r\nimport kotlin.coroutines.suspendCoroutine\r\n\r\nfun main(){\r\n  val log = logger()\r\n    \r\n  // (1)\r\n  runBlocking {\r\n    log.info(\"현재 코루틴 스코프 내의 코루틴 컨텍스트 : ${this.coroutineContext}\")\r\n    inner() // 다른 함수를 호출할 때 어떻게 되는지 확인해봅니다.\r\n  }\r\n}\r\n\r\nprivate suspend fun inner(){\r\n  val log = logger()\r\n  // (2)\r\n  log.info(\"suspend 함수 내에서의 context ${coroutineContext}\")\r\n\r\n  // (3)\r\n  var result = suspendCoroutine<String> { continuation ->\r\n    log.info(\"Continuation 객체 내의 context = ${continuation.context}\")\r\n    continuation.resume(\"OK\")\r\n  }\r\n    \r\n  // (4)\r\n  log.info(\"inner 함수 내애서의 result = $result\")\r\n}\n(1)\n(1) 에서는 runBlocking{...} 함수 내에서 코루틴 컨텍스트에 접근하는데, coroutineContext 변수로 접근했다는 것을 알 수 있습니다. runBlocking 함수의 마지막 인자는 람다인데, 이 람다 내에서 coroutineContext 필드를 접근하고 있는 것을 알 수 있습니다.\n(2)\n(2) 에서는 일반 suspend 함수에서 coroutineContext 에 접근하는 것을 보여줍니다. suspend 함수 내에서는 단순히 coroutineContext 필드를 사용해서 코루틴 컨텍스트데 접근 가능합니다.\n(3)\n(3) 에서는 suspendCoroutine 함수를 실행하고 있는데, suspendCoroutine 함수의 마지막인자인 람다를 이용하고 있습니다. 이 람다의 첫번째 인자는 continuation 타입인데, 이 continuation 타입 내의 context 필드를 통해서 CoroutineContext 필드에 접근이 가능합니다.\n(4)\nsuspendCoroutine 이 반환한 result 값을 받아서 확인해보니 정상적으로 돌려받았습니다. suspend 함수를 동기연산처럼 사용했습니다.\n위의 코드에 대한 출력결과는 아래와 같습니다.\n21:37:30.203 [main] INFO io.chagchagchag.demo.kotlin_coroutine.helper.LoggingObject -- 현재 코루틴 스코프 내의 코루틴 컨텍스트 : [BlockingCoroutine{Active}@5ec0a365, BlockingEventLoop@4fe3c938]\r\n21:37:30.210 [main] INFO io.chagchagchag.demo.kotlin_coroutine.helper.LoggingObject -- suspend 함수 내에서의 context [BlockingCoroutine{Active}@5ec0a365, BlockingEventLoop@4fe3c938]\r\n21:37:30.213 [main] INFO io.chagchagchag.demo.kotlin_coroutine.helper.LoggingObject -- Continuation 객체 내의 context = [BlockingCoroutine{Active}@5ec0a365, BlockingEventLoop@4fe3c938]\r\n21:37:30.213 [main] INFO io.chagchagchag.demo.kotlin_coroutine.helper.LoggingObject -- inner 함수 내애서의 result = OK","async-launch-등의-코루틴-빌더는-왜--으로-끝나나요#async, launch 등의 코루틴 빌더는 왜 {} 으로 끝나나요?":"async 함수를 예로 들어보겠습니다. kotlin-coroutines-core 라이브러리에서 제공하는  Builders.common.kt 파일 내의 async 함수는 아래와 같이 정의되어 있습니다.마지막 인자는 suspend CoroutineScope.() -> T 와 같이 선언되어 람다로 선언되어 있음을 확인 가능합니다.코틀린 문법을 정리하면서 자세히 정리하겠지만, 코틀린에서는 함수의 마지막인자가 람다일 경우 () 으로 감싸지 않고 { } 으로 끝낼 수 있습니다. 위의 코드에서는 세개의 인자들 중 context, start 는 모두 디폴트 값이 정해져 있고, 마지막 인자는 람다입니다. 따라서 async (...) 함수를 호출할 때에는  아래와 같은 식으로 표현하는 것이 가능해집니다.\nfun main(){\r\n    async{ // 여기부터 있는 람다 바디는 사실 async() 함수의 마지막 인자에요!!\r\n        println(\"안뇽하세요\")\r\n    }\r\n}\n그리고 kotlin-coroutine-core 에서 제공하는 async, launch, withContext 등과 같은 코루틴과 관련된 함수들을 코루틴 빌더라고 부릅니다."}},"/coroutine-dispatcher/intro":{"title":"Intro","data":{}},"/coroutine-scope-and-structured-concurrency/intro":{"title":"Intro","data":{}},"/coroutine-useful-case/intro":{"title":"Intro","data":{}},"/flow/intro":{"title":"Intro","data":{}},"/":{"title":"Introduction","data":{}},"/kotlin-basic/intro":{"title":"Intro","data":{}},"/suspend-and-fsm-cps/fsm-and-cps":{"title":"Fsm and Cps","data":{"fsm-cps#FSM, CPS":""}},"/suspend-and-fsm-cps/to-coroutine":{"title":"코루틴 코드로 바꿔보면","data":{}},"/suspend-and-fsm-cps/what-is-suspend-function":{"title":"What Is Suspend Function","data":{"코루틴의-개념-suspend-함수#코루틴의 개념, suspend 함수":"","코틀린의-코루틴#코틀린의 코루틴":"코틀린 코루틴은 비동기 프로그래밍을 위한 강력한 도구입니다.코루틴은 코드의 일부를 일시 중단하고 나중에 재개할 수 있는 경량 스레드로 볼 수 있습니다. 코루틴은 스레드 하나에서 여러 개의 코루틴으로 나눠서 병렬로 수행할 수 있습니다. 즉, 스레드에서 수행되는 개별적인 작업의 단위로 각각의 작업을 수행하는 것을 코루틴이라고 합니다. 코루틴은 코틀린에만 존재하는 것이 아닙니다. 이미 오래전에 1990년대부터 존재하던 개념이고,  c, c++, javascript, go 등 현존하는 모든 프로그래밍 언어에 존재하지만, Kotlin 에는 도입되었지만 아직 Java 에는 도입되지 않았습니다.","suspend-함수#suspend 함수":"suspend 함수는 코루틴을 구현하는 데 중요한 역할을 합니다. suspend 함수를 선언하려면  suspend 라는 키워드를 함수 앞에 붙여서 선언하면 suspend 함수가 됩니다. 이렇게 하면 컴파일러가 suspend 가 붙은 함수를 코루틴 내에서 사용할 수 있는 함수로 인식합니다. 코루틴 내에서 일시 중단이 가능한 모든 작업은 반드시 suspend 함수에서 수행되어야 합니다.","suspend-함수는-뭐고-코루틴은-뭔가요#suspend 함수는 뭐고 코루틴은 뭔가요?":"코틀린에서는 suspend 키워드를 붙인 함수가 코루틴으로 실행됩니다. 코루틴은 일시 중단할 수 있고 재개할 수 있는 개념이며 스레드보다 작은 단위의 개념입니다. 코루틴은 코루틴 내에서 여러 개의 코루틴이 분기할 수 있는데 이때 여러 개의 개별 코루틴 컨텍스트로 동작하거나 개발자가 직접 지정한 코루틴 컨텍스트 내에서 함께 동작하거나 하는 것을 지정하는 것이 가능합니다. 이런 코루틴을 사용하기 위해서는 suspend 키워드가 붙어 있어야만 가능하며 suspend 키워드는 함수에 붙일 수 있습니다. suspend 함수는 코틀린 언어가 실행될 수 있는 환경인 JVM 에 의해 실행됩니다.코틀린이 기본으로 제공하는 라이브러리 들 중 대표적인 suspend 기반의 함수들에는 launch, async , runBlocking, withContext 등이 있는데 이들 모두를 코루틴 빌더라고 이야기합니다.launch 함수는 반환값이 없는 Fire-and-forget 스타일의 코루틴을 생성하고 실행하며, async 함수는 비동기 작업의 결과를 리턴하는 코루틴을 만들어냅니다.코루틴은 멀티 스레딩과 함께 사용되어 병렬 처리를 가능하게 하지만, 코루틴은 기본적으로 단일 스레드에서 실행됩니다. 따라서 코루틴은 비동기 작업을 보다 간편하게 처리할 수 있는 동시성 프로그래밍 모델을 제공합니다.코틀린의 코루틴은 비동기적인 코드를 작성하고 관리하는 데 매우 유용한 도구이며, 코틀린 표준 라이브러리에 포함되어 있어 바로 사용할 수 있습니다.","코틀린에서-기본적으로-제공하는-suspend-함수들#코틀린에서 기본적으로 제공하는 suspend 함수들":"코틀린에서 기본적으로 제공하는 대표적인 suspend 함수는 kotlinx.coroutines패키지 내의 Builders.common.kt에 있으며 launch, async, withContext 등이 있습니다.","async-launch-withcontext-는-coroutinescope-의-확장함수#async, launch, withContext 는 CoroutineScope 의 확장함수":"async, launch, withContext 함수는 suspend 함수라고 부르기도 합니다. 한가지 알아두고 넘어가야 할 것은 async, launch, withContext 는 CoroutineScope 안에서 동작한다는 점입니다. 그리고 async, launch,withContext 는 CoroutineScope 의 확장함수로 선언되어 있습니다.","suspend-함수의-주요-특징#suspend 함수의 주요 특징":"suspend 함수의 주요 특징은 아래와 같습니다.\nsuspend 함수는 일시 중단할 수 있는 함수입니다.\nsuspend 가 적용된 함수가 실행되는 동안 일시 중단될 경우, suspend 를 실행하는 동안 내부적으로는 다른 작업을 수행하거나 대기하게 됩니다. 즉, 논블로킹 기반으로 동작합니다. suspend 함수를 호출할 때에는 이 suspend 함수를 호출한 코루틴이 일시 중단됩니다.\nsuspend 함수를 사용하면 비동기적인 작업을 수행하는 동안 UI를 블로킹하지 않고도 작업을 수행할 수 있습니다.\n예를 들어 네트워크 호출이나 파일 I/O와 같은 작업을 수행할 때 suspend 함수를 사용하여 코루틴을 일시 중단하고 나중에 결과를 받아서 처리할 수 있습니다.\nsuspend 가 적용된 함수는 suspend 가 붙은 함수에서만 호출이 가능합니다.\nSpring Webflux 는 Controller 에 suspend 함수를 지원합니다. 따라서 Controller 내에서는 suspend 함수를 실행이 가능합니다.\nsuspend 가 적용되지 않은 함수이지만 라이브러리 함수여서 수정이 불가능하고 호출역시 불가능할 경우가 있습니다. 이 경우 아래의 두 방식으로 일반함수내에서 suspend 함수를 감싸서 실행하는 방식으로 사용이 가능합니다.\nkotlin-coroutines-reactor 의 mono 함수 내부에서 suspend 함수를 실행\nCoroutineScope(CoroutineDispatcher).future { ... } 를 사용하는 방식","suspend-기반의-kotlin-내장-함수들#suspend 기반의 kotlin 내장 함수들":"async, launch, withContext 말고도 코틀린의 kotlinx-coroutines-core 에서 제공하는 suspend 가 적용된 함수들은 많습니다. kotlin 라이브러리에서 제공하는 대표적으로 잘 알려진 suspend 함수들은 아래와 같습니다.\nwithContext : 코루틴 컨텍스트를 변경하는 함수입니다. 다른 스레드에서 코드를 실행하거나, 특정 디스패처에 작업을 보내는 것이 가능합니다.\ndelay : 일정 시간 동안 코루틴을 일시 중단하는 함수입니다. 주로 테스트나 간단한 딜레이를 구현할 때 사용됩니다.\nawait: Deferred 객체의 결과를 기다리는 함수로, async 함수로 생성된 Deferred 객체의 결과를 가져올 때 사용됩니다.\nlaunch: 백그라운드에서 비동기적으로 새로운 코루틴을 실행하는 함수로, 반환 값이 없는 Fire-and-forget 스타일의 코루틴을 생성합니다.\nrunBlocking: 새로운 블록 내에서 코루틴을 실행하는 함수로, 주로 메인 함수나 테스트 코드에서 사용되며, 코루틴을 기다리는 동안 블로킹을 유지합니다.\ncoroutineScope: 지정된 블록 내에서 새로운 코루틴 스코프를 생성하는 함수로, 지정된 블록 내의 코루틴이 완료될 때까지 대기합니다.\nselect: 여러 개의 중단 가능한 조건을 동시에 처리할 수 있는 함수로, 먼저 발생하는 이벤트를 처리하고 나머지는 무시합니다.\nsupervisorScope: 자식 코루틴이 실패하더라도 부모 코루틴이 중단되지 않도록 하는 슈퍼바이저 스코프를 생성하는 함수로, 자식 코루틴의 실패를 격리합니다.","suspend-함수는-어디에서-실행되나요#suspend 함수는 어디에서 실행되나요?":"중단된 suspend 함수는 재개될 때 CoroutineDispatcher 가 어느 스레드에서 실행할지 결정합니다.CoroutineDispatcher 역시 CoroutineContext 의 일종입니다. CoroutineContext 에는 CoroutineName, Job, ThreadLocalElement, ReactorContext 등이 있습니다.CoroutineContext 의 개념과 원리, 예제, CoroutineDispatcher 의 개념, 종류 등의 개념은 이 블로그 내에서 별도의 카테고리에 분류해서 정리하고 있습니다. 정리가 완료되면 링크를 추가하겠습니다.\nTOOD : 링크 추가\nsuspend 함수를 통해 만들어진 코루틴은 하나의 스레드에서 실행되다가 중지된 후 다른 스레드에서 이어서 실행할 수 있습니다. 비동기연산을 논 블로킹하게 수행하기 때문입니다.\nTODO : 그림 추가","suspend-함수는-비동기인가요--동기-연산인가요#suspend 함수는 비동기인가요 ? 동기 연산인가요?":"suspend 함수는 비동기 연산으로 수행되게끔 할 수도 있고 비동기 코드인데 동기연산처럼 수행하게끔 await() 등의 함수를 사용해서 동기코드처럼 사용하는 것도 가능합니다. 다만 이렇게 비동기 코드를 동기 코드 처럼 순차적으로 처리되는 식으로 작성한 코드를 흔히 블로킹 방식 코드로 착각하게 된다는 점을 주의해야 합니다. 비동기 적인 연산을 하는 suspend 함수를 동기 코드 처럼 동작하도록 await() 함수 등을 사용할 때, await() 함수에 대한 IO Bound 작업이 끝날 때 까지 뒷단에서 코루틴 디스패처는 다른 작업들을 관리해서 수행시키고 조율시킵니다.","fsm-cps-suspend-함수#FSM, CPS, suspend 함수":"suspend 가 붙은 함수를 suspend 함수 없이 내부적인 구현을 구현하면 결국은 FSM(Finite State Machine), CPS(Continuation Passing Style) 을 기반으로 한 재귀 호출구문으로 이뤄지게 됩니다. FSM 이라는 것은 유한 상태 기계라는 의미인데 일종의 label 을 통해 상태를 인식해서 다음 상태로 넘어가게 해주는 것을 의미하고 CPS 는 다음 상태로 지속이 가능한 객체인 Continuation 을 넘겨주는 방식을 의미합니다. Continuation 객체 내에는 주로 데이터를 처리하거나 바인딩하기 위한 구조체 같은 데이터가 포함됩니다.\n더 자세한 내용은 FSM, CPS 문서에 따로 정리해두겠습니다.","suspend-함수-예제#suspend 함수 예제":"","suspend-함수는-일시-중단할-수-있는-함수#suspend 함수는 일시 중단할 수 있는 함수":"suspend 함수는 일시 중단하는 함수입니다. 아래는 그 코드입니다.\n그런데 이렇게 일시중단한다고 해서 코드 자체가 블로킹 상태가 되는 것이 아닙니다. 블로킹이라고 하는 것은 다른 작업을 수행하지 못하는 상태를 의미하는데, suspend 함수로 일시 중단 상태가 되었을 때 뒷단에서는 코루틴 디스패처 안에 쌓여있는 다른 작업을 수행하면서 suspend 함수의 동작이 끝나기를 기다립니다.이렇게 하는 이유는 현대적인 애플리케이션들이 계산작업으로 인한  CPU 점유 보다는 IO로 인한 응답대기를 하는 것으로 인한 CPU 점유가 더 높기 때문입니다. IO의 응답이 오기 전까지 스레드 하나를 차지하고 있는 것은 낭비이기 때문에 하나의 스레드 내에서 여러 개의 코루틴으로 분리하고 하나의 코루틴이 IO 작업을 완료하기 전까지 다른 코루틴을 코루틴 디스패처가 분배하면서 작업을 합니다.저 역시도 코루틴의 suspend 함수를 학습하면서 위의 코드가 블로킹이라고 착각했었고 코틀린을 배우느라 알게된 패캠 강사님도 위의 코드를 처음에는 블로킹 코드로 착각했다고 하셨었습니다. 많은 사람들이 착각하는 부분입니다. 다른 일을 오랫동안 하다가 다시 코틀린 코루틴을 다룰 때도 까먹었다가 다시 생각날 수도 있는 개념이기에 코루틴은 블로킹이 아니라 논블로킹이고 작업을 중단해두었지만, 내부적으로는 다른 작업을 처리하게끔 해둔 상태에서 중단한 것이라고 개념을 주의해서 기억해둬야 할 필요가 있습니다.","suspend-함수는-논블로킹-기반의-비동기-연산을-수행#suspend 함수는 논블로킹 기반의 비동기 연산을 수행":"","suspend-함수는-suspend-함수에서만-호출-가능#suspend 함수는 suspend 함수에서만 호출 가능":"","spring-webflux-의-에서는-suspend-를-지원#Spring Webflux 의 에서는 suspend 를 지원":"Spring Webflux 는 Controller 에 suspend 함수를 지원합니다. 따라서 아래 코드와 같이 Controller 내에서는 suspend 함수를 실행이 가능합니다.\npackage io.chagchagchag.demo.kotlin_coroutine\r\n\r\n// ...\r\n\r\n@RestController\r\n@RequestMapping(\"/healthcheck\")\r\nclass HealthCheckController {\r\n\r\n  private suspend fun ok(): String = \"OK\"\r\n\r\n  @GetMapping(\"/ready\")\r\n  suspend fun ready(): String{\r\n    return ok()\r\n  }\r\n}","mono-completablefuture-를-반환하는-라이브러리-함수가-suspend-함수가-아닐-경우#Mono, CompletableFuture 를 반환하는 라이브러리 함수가 suspend 함수가 아닐 경우":"kotlin-coroutines-reactor 의 mono 함수 내부에서 suspend 함수를 실행\nCoroutineScope(CoroutineDispatcher).future { ... } 를 사용하는 방식\nCoroutineScope(CoroutineDispatcher).future { ... }  내에서 suspend 함수를 실행하고, 반환되는 CompletableFuture를 thneAccept 등을 통해서 실행\nTODO : 그림 추가"}}}