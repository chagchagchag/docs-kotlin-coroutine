{"/channel/intro":{"title":"Intro","data":{}},"/coroutine-context/coroutine-exception-handler":{"title":"Coroutine Exception Handler","data":{"coroutineexceptionhandler#CoroutineExceptionHandler":""}},"/coroutine-context/coroutine-context-types-features-and-uml":{"title":"Coroutine Context Types Features and Uml","data":{"coroutinecontext-의-종류-특징-uml#CoroutineContext 의 종류, 특징, UML":"","참고#참고":"Coroutine context and dispatchers\n주요 API 정의 문서\nkotlin.coroutines package-level declarations\nCoroutineContext\nEmptyCoroutineContext, CoroutineContextImpl.kt\nElement,\nAbstractCoroutineContextElement\nCoroutineName\nCoroutineDispatcher\nThreadContextElement\nCoroutineExceptionHandler\nJob\nJob.kt, Supervisor.kt, SupervisorJob, CompletableJob\nJobSupport.kt","coroutinecontext-interface#CoroutineContext Interface":"kotlin-coroutines-core 라이브러리 내에 정의된 CoroutineContext 타입은 interface 로 정의되어 있습니다.구체적인 구현부는 // ... 으로 생략했고 주석은 모두 지워두었습니다. 실제 코드는 IDE 에서 직접 열어보시거나 github.com/JetBrains/kotlin/.../CoroutineContext.kt 를 참고해주시기 바랍니다.\n@SinceKotlin(\"1.3\")\r\npublic interface CoroutineContext {\r\n    public operator fun <E : Element> get(key: Key<E>): E?\r\n    public fun <R> fold(initial: R, operation: (R, Element) -> R): R\r\n    public operator fun plus(context: CoroutineContext): CoroutineContext =\r\n        if (context === EmptyCoroutineContext) this \r\n        else \r\n    \t// ...\r\n    \r\n    public fun minusKey(key: Key<*>): CoroutineContext\r\n    public interface Key<E : Element>\r\n    public interface Element : CoroutineContext {\r\n        public val key: Key<*>\r\n        public override operator fun <E : Element> get(key: Key<E>): E? =\r\n            if (this.key == key) this as E else null\r\n\r\n        public override fun <R> fold(initial: R, operation: (R, Element) -> R): R =\r\n            operation(initial, this)\r\n\r\n        public override fun minusKey(key: Key<*>): CoroutineContext =\r\n            if (this.key == key) EmptyCoroutineContext else this\r\n    }\r\n}\n이렇게 interface 로 선언해두었기 때문에 CoroutineContext 를 implements 하는 각각의 구체 클래스들은 CoroutineContext 타입으로 추상화가 가능합니다. 일반적으로 CoroutineContext 타입을 직접 바로 사용하지는 않습니다. CoroutineContext interface 를 extends 하는 EmptyCoroutineContext, Element, CombinedContext interface 를 implements 해서 사용합니다.EmptyCoroutineContext, Element, CombinedContext interface 들은 모두 하나만 존재하는 존재인지, 여러개의 요소들을 표현한는 존재인지 등에 따라서 용도별로 내부 구현이 모두 명확하게 다르게 구현되어있습니다.","emptycoroutinecontext-element-combinedcontext-key#EmptyCoroutineContext, Element, CombinedContext, Key":"CoroutineContext 타입은 바로 사용되지는 않고 크게 3 종류로 나누서 EmptyCoroutineContext, Element, CombinedContext 타입으로 사용됩니다. 각각의 역할은 아래와 같습니다.\nEmptyCoroutineContext\nEmptyCoroutineContext 는 kotlin.coroutines 패키지 내의 CoroutineContextImpl.kt 파일에 정의되어 있습니다.\nEmtpyCoroutineContext 는 CoroutineContext interface를 implements 하는 구체 object 입니다. (클래스가 아닌 object 타입입니다)\nElement 를 포함하지 않는 비어있는 CoroutineContext 를 표현하는 구체타입입니다.\nOptional.empty, Mono.empty 처럼 비어있는 객체를 표현할 때 사용합니다.\nElement\nElement 는 CoroutineContext interface 내에 선언되어 있는 interface 입니다. 정확하게는 CoroutineContext interface 내부에 존재하므로 CoroutineContext.Element 로 표시됩니다.\nElement 는 CoroutineContext interface 를 extends 하고 있기에 CoroutineContext 의 기능들을 확장하고 있습니다.\nElement 는 Element 가 하나인 상태를 의미합니다. reactor 의 Mono 처럼 하나만 존재하는 Element 를 의미합니다.\n잘 알려져있는 Element 구현체 또는 타입으로는 CoroutineName, CoroutineDispatcher, CoroutineExceptionHandler, Job, ThreadContextElement 가 있습니다.\n코틀린 라이브러리에서 많이 보이는 AbstractCoroutineContextElement 클래스는 Element 를 implements 한 abstract 클래스입니다.\n잘 알려져있는 CoroutineDispatcher 클래스, CoroutineName 클래스는 AbstractCoroutineContextElement 라고 하는 Element 타입을 extends 한 클래스입니다.\n코틀린의 Job interface 역시 Element interface 를 extends 하고 있으며\nCombinedContext (참고 : CoroutineContextImpl.kt )\nkotlin.coroutines 패키지 내의 CoroutineContextImpl.kt 파일에 정의되어 있는 internal 클래스입니다.\nElement 를 두 개 이상 담을 때 사용하는 타입입니다.\n트리 구조를 통해 left 에는 CombinedContext, right 에는 Element 를 두는데 가장 마지막 CombinedContext 의 left 에는 Element 가 위치하게 됩니다. CombinedContext 의 자료구조에 대한 설명은 문서의 하단에 자세히 정리합니다.\n이렇게 CoroutineContext interface, CoroutineContextImpl.kt 등에 정의된 EmptyCoroutineContext, Element, CombinedContext 는 모두 연산자 오버로딩으로 plus, minusKey, get 등이 정의되어 있기 때문에 +, -기호로 plus, minusKey 연산을 수행할 수 있고 [key] 를 통해서 get 연산을 수행할 수 있습니다.위에서 살펴본 3종류의 타입들과는 다르게 Key 라는 타입이 있습니다. Key 역시 interface 로 선언된 타입입니다. 이 Key 는 Element 를 구별하기 위해 사용되며 CombinedContext 에서 사용됩니다.","coroutinecontext-의-연산자-오버로딩#CoroutineContext 의 연산자 오버로딩":"CoroutineContext 는 get, plus, minusKey, fold 연산을 지원합니다. CoroutineContext Interface 코드의 요약본을 살펴보면 아래와 같습니다.\nget(Key) : 특정 Key 를 갖는 Element 타입을 리턴하는 메서드입니다.\nplus(CoroutineContext) : 현재 CoroutineContext 에 다른 CoroutineContext 를 병합하는 연산을 수행하는 메서드입니다. 만약 이미 같은 Key 를 갖는 Element 가 다른 Context 등에 이미 존재하고 있다면, 그 Element 를 Update 합니다.\nminusKey(Key) : 현재 CoroutineContext 내에서 주어진 Key 에 해당하는 Element 를 제거한 후 CoroutineContext 를 반환합니다.\n@SinceKotlin(\"1.3\")\r\npublic interface CoroutineContext {\r\n    public operator fun <E : Element> get(key: Key<E>): E?\r\n    public fun <R> fold(initial: R, operation: (R, Element) -> R): R\r\n    public operator fun plus(context: CoroutineContext): CoroutineContext =\r\n        if (context === EmptyCoroutineContext) this \r\n        else \r\n    \t// ...\r\n    \r\n    public fun minusKey(key: Key<*>): CoroutineContext\r\n    public interface Key<E : Element>\r\n    public interface Element : CoroutineContext {\r\n        public val key: Key<*>\r\n        public override operator fun <E : Element> get(key: Key<E>): E? =\r\n            if (this.key == key) this as E else null\r\n\r\n        public override fun <R> fold(initial: R, operation: (R, Element) -> R): R =\r\n            operation(initial, this)\r\n\r\n        public override fun minusKey(key: Key<*>): CoroutineContext =\r\n            if (this.key == key) EmptyCoroutineContext else this\r\n    }\r\n}\n이미 존재하는 CoroutineContext 에 다른 CoroutineContext 를 결합해서 사용하는 경우는 굉장히 많습니다. 이렇게 두개 이상의 CoroutineContext 를 합쳐서 여러 개의 CoroutineContext 를 갖는 자료구조는 CombinedContext 라는 타입으로 표현을 합니다. 이렇게 두개 이상의 CoroutineContext 를 갖는 자료구조는 CombinedContext 라는 타입을 통해 표현하며, CombinedContext 의 자료 구조는 트리와 같은 구조입니다. 이 CombinedContext 의 데이터 구조는 이 문서의 하단에서 정리합니다.이 CombinedContext 자료구조는 CoroutineContext 타입을 통해서 이루어지는 것이고 CombinedContext 는 CoroutineContext 를 구체화 했기에 CoroutineContext 가 지원하는 연산자 오버로딩이 적용 되니다. 예를 들면 여러개의 CoroutineContext 가 더해지거나 빼지거나 get 을 하기 위해 연산자 오버로딩이 되어 있습니다.이번 Step 에서는 이렇게 특정 CoroutineContext 를 더하고 ,빼고, get 을 하는 것에 대한 예제를 살펴보겠습니다.","plus-연산#plus 연산":"CoroutineContext 의 plus 연산은 아래와 같은 방식으로 이뤄집니다.\nEmptyCoroutineContext + Element 연산 = Element\nElement 로 합쳐집니다.\nElement 와 Empty 를 더하는 연산은 Element 하나로 취급해서 CoroutineContext 1개 짜리의 조합이 된다고 생각하면 쉽습니다.\nElement + Element 연산 = CombinedContext\nCombinedContext 가 됩니다.\nElement 타입 2개가 합쳐진 것은 CoroutineContext 타입 2개 이상의 타입이 되는 것이기 때문입니다.\nElement + Element 연산 = Element\nElement + Element 를 할 때 Element 가 모두 같은 CoroutineContext Key 를 가지면 하나의 Element 로 합쳐진다고 간주해서 결과는 Element 가 됩니다.\nCombinedContext + Element 연산 = CombinedContext\nCombinedContext 가 됩니다.\n이미 두 개 이상의 요소에 하나를 더 append 하기에 CombinedContext 가 됩니다.\n두 개 이상의 CoroutineContext 에 Element 를 합치는 것은 이미 존재하는 2개 이상의 CoroutineContext에 1개의 CoroutineContext를 append 하는 연산으로 생각하면 쉽습니다.\n아래는 예제 코드입니다.\npackage io.chagchagchag.demo.kotlin_coroutine.coroutine_context\r\n\r\nimport io.chagchagchag.demo.kotlin_coroutine.helper.logger\r\nimport kotlinx.coroutines.CoroutineName\r\nimport kotlinx.coroutines.Dispatchers\r\nimport kotlinx.coroutines.Job\r\nimport kotlin.coroutines.EmptyCoroutineContext\r\n\r\nfun main(){\r\n  val log = logger()\r\n  // (1)\r\n  val emptyContext = EmptyCoroutineContext // object 타입이기에 생성자를 호출하지 않아도 바로 대입이 됩니다.\r\n  log.info(\"emptyContext = $emptyContext\")\r\n\r\n  // (2)\r\n  val element1 = CoroutineName(\"배고파요\")\r\n  val mergedContext1 = emptyContext + element1\r\n  log.info(\"mergedContext1 = $mergedContext1, 클래스 = ${mergedContext1.javaClass.simpleName}\")\r\n\r\n  // (3)\r\n  val element2 = CoroutineName(\"한입만\")\r\n  val mergedContext2 = mergedContext1 + element2\r\n  log.info(\"mergedContext2 = $mergedContext2, 클래스 = ${mergedContext2.javaClass.simpleName}\")\r\n\r\n  // (4)\r\n  val element3 = Dispatchers.IO\r\n  val mergedContext3 = mergedContext2 + element3\r\n  log.info(\"mergedContext3 = $mergedContext3, 클래스 = ${mergedContext3.javaClass.simpleName}\")\r\n\r\n  // (5)\r\n  val element4 = Job()\r\n  val mergedContext4 = mergedContext3 + element4\r\n  log.info(\"mergedContext4 = $mergedContext4, class = ${mergedContext4.javaClass.simpleName}\")\r\n}\n(1)\nEmptyCoroutineContext 를 출력해봅니다.\nEmptyCoroutineContext 는 object 타입이기에 생성자를 호출하지 않아도 바로 대입이 됩니다.\n(2)\nEmptyCoroutineContext 와 Element 를 더하고 있습니다.\nEmpty + Element 이므로 결과는 Element 가 됩니다.\n출력결과를 보면 CoroutineName 으로 출력됩니다. CoroutineName 은 AbstractCoroutineContextElement 타입인데, Element 타입으로 추상화가 가능합니다.\n(3)\nElement + Element 를 수행하지만 같은 CoroutineContext Key 를 가지고 있습니다. 따라서 같은 CoroutineContext 에 합쳐지는 것이 되기에 결과는 Element 가 됩니다.\n출력결과를 보면 CoroutineName 으로 출력됩니다. CoroutineName 은 AbstractCoroutineContextElement 타입인데, Element 타입으로 추상화가 가능합니다.\n(4)\nElement + Element 를 수행하게 되므로 결과는 CombinedContext 가 됩니다.\n출력결과를 보면 CombinedContext 가 출력됩니다.\nCoroutineDispatcher 는 AbstractCoroutineContextElement 타이기에 Element 타입으로 추상화가 가능합니다.\n(5)\nCombinedContext + Element 를 수행하므로 결과는 CombinedContext 가 됩니다.\n출력결과를 보면 CombinedContext 가 출력됩니다.\nJob() 은 Job.kt 에 정의된 함수이고 실제로는 JobSupport.kt 내에 정의된 JobImpl 이라는 internal class 타입입니다. 이 JobImpl class 역시 Job 타입인데, Job 은 interface 타입이고, CoroutineContext.Element 를 extends 하고 있습니다. 따라서 Element 로 추상화가 가능합니다.\n01:47:33.264 [main] INFO io...LoggingObject -- emptyContext = EmptyCoroutineContext\r\n01:47:33.280 [main] INFO io...LoggingObject -- mergedContext1 = CoroutineName(배고파요), 클래스 = CoroutineName\r\n01:47:33.285 [main] INFO io...LoggingObject -- mergedContext2 = CoroutineName(한입만), 클래스 = CoroutineName\r\n01:47:33.329 [main] INFO io...LoggingObject -- mergedContext3 = [CoroutineName(한입만), Dispatchers.IO], 클래스 = CombinedContext\r\n01:47:33.351 [main] INFO io...LoggingObject -- mergedContext4 = [CoroutineName(한입만), JobImpl{Active}@5442a311, Dispatchers.IO], class = CombinedContext","minuskey-연산#minusKey 연산":"CombinedContext 의 minusKey 연산은 아래와 같은 방식으로 이뤄집니다. 요소를 삭제할 때에는 key 를 통해 해당 Element 가 있는지 조회해서 삭제합니다.\nCombinedContext - Element = CombinedContext\nCombinedContext 에서 Element 를 하나 빼도 2개 이상인 경우에는 결과가 CombinedContext 가 됩니다.\nCombinedContext - Element = Element\nCombinedContext 에서 Element를 하나 빼서 CoroutineContext가 1개가 되었을 경우에는  Element 가 됩니다.\nElement - Element = EmptyCoroutineContext\nCoroutineContext 1개에서 CoroutineElement 1개를 빼므로 0개가 되어서 EmptyCoroutineContext 가 됩니다.\n아래는 예제 코드입니다.\npackage io.chagchagchag.demo.kotlin_coroutine.coroutine_context\r\n\r\nimport io.chagchagchag.demo.kotlin_coroutine.helper.logger\r\nimport kotlinx.coroutines.CoroutineDispatcher\r\nimport kotlinx.coroutines.CoroutineName\r\nimport kotlinx.coroutines.Dispatchers\r\nimport kotlinx.coroutines.Job\r\n\r\n@OptIn(ExperimentalStdlibApi::class)\r\nfun main(){\r\n  val log = logger()\r\n  // (1)\r\n  val context1 = CoroutineName(\"짬뽕\") + Dispatchers.IO + Job()\r\n  log.info(\"context1 = $context1, 클래스 = ${context1.javaClass.simpleName}\")\r\n  // (2)\r\n  val minus1 = context1.minusKey(Job)\r\n  log.info(\"minus1 = $minus1, 클래스 = ${minus1.javaClass.simpleName}\")\r\n  // (3)\r\n  val minus2 = minus1.minusKey(Job)\r\n  log.info(\"minus2 = $minus2, 클래스 = ${minus2.javaClass.simpleName}\")\r\n  // (4)\r\n  val minus3 = minus2.minusKey(CoroutineDispatcher)\r\n  log.info(\"minus3 = $minus3, 클래스 = ${minus3.javaClass.simpleName}\")\r\n  // (5)\r\n  val minus4 = minus3.minusKey(CoroutineName)\r\n  log.info(\"minus4 = $minus4, 클래스 = ${minus4.javaClass.simpleName}\")\r\n}\n(1)\n3 종류의 CoroutineContext 를 더해서 3개의 CoroutineContext 가 존재하는 CombinedContext 를 만듭니다.\n따라서 결과값은 CombinedContext 가 출력됩니다.\n(2)\n(1) 에서 추가한 Job 타입의 CoroutineContext 를 제거합니다. 출력결과를 보면 Job 타입의 CoroutineContext 가 제거되고 Dispatchers.IO, CoroutineName(짬뽕) 만 남습니다.\n코드와 출력결과를 통해 minusKey()의 인자에는 코틀린 클래스 (KClass) 타입을 넘기면 된다는 사실을 알수 있습니다.\n(3)\n(2) 에서 했던 연산을 한번 더 해서 똑같이 Job 타입을 빼려 할 때 어떻게 되는지를 확인합니다.\nJob 타입은 이제 더 이상 CoroutineContext 내에 존재하지 않기에 출력결과는 달라지지 않습니다.\n(4)\nCoroutineDispatcher 를 뺍니다. minusKey 를 통해 CoroutineContext 에 CoroutineDispatcher 타입이 있는지 검색한 후 CoroutineDispatcher 타입이 있다면 해당 타입을 CoroutineContext 에서 삭제합니다.\n출력결과는 CoroutineDispatcher 가 제거된 후의 결과값이 출력됩니다.\n(5)\n마지막으로 남은 CoroutineName 객체를 지웁니다.\nminusKey 함수에 CoroutineName 클래스 타입을 전달해줬고, 정상적으로 CoroutineName 객체가 삭제되었습니다.\n출력결과\n02:49:07.584 [main] INFO io...LoggingObject -- context1 = [CoroutineName(짬뽕), JobImpl{Active}@5e3a8624, Dispatchers.IO], 클래스 = CombinedContext\r\n02:49:07.587 [main] INFO io...LoggingObject -- minus1 = [CoroutineName(짬뽕), Dispatchers.IO], 클래스 = CombinedContext\r\n02:49:07.587 [main] INFO io...LoggingObject -- minus2 = [CoroutineName(짬뽕), Dispatchers.IO], 클래스 = CombinedContext\r\n02:49:07.589 [main] INFO io...LoggingObject -- minus3 = CoroutineName(짬뽕), 클래스 = CoroutineName\r\n02:49:07.590 [main] INFO io...LoggingObject -- minus4 = EmptyCoroutineContext, 클래스 = EmptyCoroutineContext","get-연산#get 연산":"package io.chagchagchag.demo.kotlin_coroutine.coroutine_context\r\n\r\nimport io.chagchagchag.demo.kotlin_coroutine.helper.logger\r\nimport kotlinx.coroutines.CoroutineDispatcher\r\nimport kotlinx.coroutines.CoroutineName\r\nimport kotlinx.coroutines.Dispatchers\r\nimport kotlinx.coroutines.Job\r\n\r\n@OptIn(ExperimentalStdlibApi::class)\r\nfun main(){\r\n  val log = logger()\r\n  // (0)\r\n  var multipleContexts = CoroutineName(\"배고파요\") + Dispatchers.IO\r\n  // (1)\r\n  val hungryElement = multipleContexts[CoroutineName]\r\n  log.info(\"hungryElement = $hungryElement, 클래스 = ${hungryElement?.javaClass?.simpleName}\")\r\n  // (2)\r\n  val dispatcherElement = multipleContexts[CoroutineDispatcher]\r\n  log.info(\"dispatcherElement = $dispatcherElement, 클래스 = ${dispatcherElement?.javaClass?.simpleName}\")\r\n  // (3)\r\n  val dispatcherElementGet = multipleContexts[CoroutineDispatcher]\r\n  log.info(\"dispatcherElementGet = $dispatcherElementGet, 클래스 = ${dispatcherElementGet?.get(CoroutineDispatcher)}\")\r\n  // (4)\r\n  val jobElement = multipleContexts[Job]\r\n  log.info(\"jobElement = $jobElement, 클래스 = ${jobElement?.get(Job)}\")\r\n}\n(0)\n예제를 위한 CombinedContext 를 만듭니다.\nCoroutineName, Dispatchers.IO 를 더해서 총 2개의 CoroutineContext 가 존재하는 CombinedContext 를 생성합니다.\n(1)\nCoroutineName 타입의 CoroutineContext Element가 CoroutineContext 내에 존재하는지 get 연산을 통해 조회합니다.\n존재하고 있기에 출력결과는 CoroutineName 이 출력됩니다.\n(2)\nCoroutineDispatcher 타입의 CoroutineContext Element 가 CoroutineContext 내에 존재하는지 get 연산을 [Key] 연산을 통해 조회합니다.\n존재하고 있기에 출력결과는 CoroutineDispatcher 가 출력됩니다.\n(3)\nCoroutineDispatcher 타입의 CoroutineContext Element 가 CoroutineContext 내에 존재하는지 get 연산을 get(Key) 메서드를 통해 조회합니다.\n존재하고 있기에 출력결과는 CoroutineDispatcher 가 출력됩니다.\n(4)\nJob 타입의 CoroutineContext Element 가 CoroutineContext 내에 존재하는지 get 연산을 [Key] 연산을 통해 조회합니다.\n존재하지 않기에 출력결과는 null 이 출력됩니다.\n출력결과\n03:21:28.908 [main] INFO io...LoggingObject -- hungryElement = CoroutineName(배고파요), 클래스 = CoroutineName\r\n03:21:28.918 [main] INFO io...LoggingObject -- dispatcherElement = Dispatchers.IO, 클래스 = DefaultIoScheduler\r\n03:21:28.919 [main] INFO io...LoggingObject -- dispatcherElementGet = Dispatchers.IO, 클래스 = Dispatchers.IO\r\n03:21:28.924 [main] INFO io...LoggingObject -- jobElement = null, 클래스 = null","combinedcontext-자료구조#CombinedContext 자료구조":"코틀린에서는 CorutineContext에 여러개의 CoroutineContext가 존재하면 CombinedContext 타이으로 이것을 관리합니다.CombinedContext 는 트리와 비슷한 모습의 자료구조인데, left, element 라는 필드를 지속해서 아래로 뻗어나가는 방식으로 돤리합니다.\nleft\nleft 는 CombinedContext 또는 Element 를 가리킵니다.\nelement\nelement 는 가장 최근에 추가된 element 를 가리키는 역할을 합니다.\nplus 연산을 통해 CoroutineContext 에 Element 를 추가할 때\n추가하려는 Element 가 CoroutineContext 내에 이미 존재하는 Element 일 경우에는\n기존의 Element 를 업데이트 해서 덮어씁니다.\n추가하려는 Element 가 CoroutineContext 내에 존재하지 않는 새로운 Element 일 경우에는\nCoroutineContext 의 left에 새로운 Element 를 element 필드로 갖는 CombinedContext 를 생성합니다.\nCombinedContext 클래스는 internal 클래스이며 CoroutineContextImpl.kt 에서 확인가능합니다.멤버필드로 left, element 를 갖는  것을 확인 가능합니다.\n// ...\r\n@SinceKotlin(\"1.3\")\r\ninternal class CombinedContext(\r\n    private val left: CoroutineContext,\r\n    private val element: Element\r\n) : CoroutineContext, Serializable {\r\n\r\n    override fun <E : Element> get(key: Key<E>): E? {\r\n        var cur = this\r\n        while (true) {\r\n            cur.element[key]?.let { return it }\r\n            val next = cur.left\r\n            if (next is CombinedContext) {\r\n                cur = next\r\n            } else {\r\n                return next[key]\r\n            }\r\n        }\r\n    }\r\n\r\n    public override fun <R> fold(initial: R, operation: (R, Element) -> R): R =\r\n        operation(left.fold(initial, operation), element)\r\n\r\n    public override fun minusKey(key: Key<*>): CoroutineContext {\r\n        element[key]?.let { return left }\r\n        val newLeft = left.minusKey(key)\r\n        return when {\r\n            newLeft === left -> this\r\n            newLeft === EmptyCoroutineContext -> element\r\n            else -> CombinedContext(newLeft, element)\r\n        }\r\n    }\r\n\r\n    private fun size(): Int {\r\n        var cur = this\r\n        var size = 2\r\n        while (true) {\r\n            cur = cur.left as? CombinedContext ?: return size\r\n            size++\r\n        }\r\n    }\r\n\r\n    private fun contains(element: Element): Boolean =\r\n        get(element.key) == element\r\n\r\n    private fun containsAll(context: CombinedContext): Boolean {\r\n        var cur = context\r\n        while (true) {\r\n            if (!contains(cur.element)) return false\r\n            val next = cur.left\r\n            if (next is CombinedContext) {\r\n                cur = next\r\n            } else {\r\n                return contains(next as Element)\r\n            }\r\n        }\r\n    }\r\n\r\n    override fun equals(other: Any?): Boolean =\r\n        this === other || other is CombinedContext && other.size() == size() && other.containsAll(this)\r\n\r\n    override fun hashCode(): Int = left.hashCode() + element.hashCode()\r\n\r\n    override fun toString(): String =\r\n        \"[\" + fold(\"\") { acc, element ->\r\n            if (acc.isEmpty()) element.toString() else \"$acc, $element\"\r\n        } + \"]\"\r\n\r\n    private fun writeReplace(): Any {\r\n        val n = size()\r\n        val elements = arrayOfNulls<CoroutineContext>(n)\r\n        var index = 0\r\n        fold(Unit) { _, element -> elements[index++] = element }\r\n        check(index == n)\r\n        @Suppress(\"UNCHECKED_CAST\")\r\n        return Serialized(elements as Array<CoroutineContext>)\r\n    }\r\n\r\n    private class Serialized(val elements: Array<CoroutineContext>) : Serializable {\r\n        companion object {\r\n            private const val serialVersionUID: Long = 0L\r\n        }\r\n\r\n        private fun readResolve(): Any = elements.fold(EmptyCoroutineContext, CoroutineContext::plus)\r\n    }\r\n}","대표적인-coroutinecontext-의-종류들#대표적인 CoroutineContext 의 종류들":"TODO : 정리필요","abstractcoroutinecontextelement-타입#AbstractCoroutineContextElement 타입":"CoroutineName\nCorutineDispatcher","coroutinecontextelement-타입#CoroutineContext.Element 타입":"CoroutineExceptionHandler\nThreadContextElement\nJob","coroutineexceptionhandler#CoroutineExceptionHandler":"","threadcontextelement#ThreadContextElement":"","job#Job":"JobSupport.kt 파일, Superviser.kt 파일에 주요 구현체가 있으며, JobSupport.kt 내에는 JobSupport 클래스 외에도 여러 클래스들이 존재합니다. 하지만, JobSupport 는 Deprecated 될 예정이기에 CompletedJob interface 내에서 다른 interface 를 확장(상속) 받는 방식으로 이 문제를 해결할 것으로 보입니다.복잡하게 정리했지만, 결국은 Job 역시도 CoroutineContext.Element 타입이라고 이해하면 된다. 이렇게 이해하면 편합니다.\nJob","threadcontextelement-1#ThreadContextElement":"TODO: 정리 예정. 다른 작업이 더 중요도가 높다고 판단해서 잠시 스킵"}},"/coroutine-context/intro":{"title":"Intro","data":{}},"/coroutine-scope-and-structured-concurrency/coroutine":{"title":"Coroutine","data":{}},"/coroutine-context/what-is-coroutine-context":{"title":"What Is Coroutine Context","data":{"coroutinecontext#CoroutineContext":"자바에서는 Thread 에서 공유할 데이터를 ThreadLocal 을 통해 공유합니다. 하지만 suspend 함수에서 코루틴 기반의 연산을 할 경우에는 이것이 불가능합니다. 코틀린에서는 코틀린의 코루틴에서 사용되는 하나의 데이터 문맥을 CoroutineContext 라고 부릅니다.그리고 이 CoroutineContext 는 Java 의 ThreadLocal 처럼 전역적으로 공유하는 것이 아니라 어떤 코루틴에서 생성했는지 여부 등에 따라서 지역적인 특성을 가집니다. 개인적으로는 코틀린의 코루틴을 처음 접할 때 이런 점이 Java 보다는 더 매력적으로 느껴졌던 것 같습니다. 코루틴 컨텍스트는 서로 더해서 합칠수도 있고, 코루틴 컨텍스트 내에서 특정 코루틴 컨텍스트를 삭제한는 것도 가능합니다. 그리고 map 의 get 연산처럼 특정 코루틴 컨텍스트 타입을 통해서 그 코루틴 컨텍스트를 조회해서 가져오는 것 역시 가능합니다.Java 의 ThreadLocal 보다 훨씬 많은 연산을 제공하기도 하고, 코루틴 컨텍스트를 트리 구조를 통해서 관리할 수 도 있으며 코루틴 컨텍스트 간 병합/삭제 역시 가능하다는 점은 코루틴 컨텍스트를 다루는 데에 있어서 유연함을 제공합니다. 이렇게 여러 연산을 수행하고 병합/삭제 기능 등에 대한 설명은 이번 문서 이후의 다른 문서에 정리해두었습니다.","threadlocal#ThreadLocal":"Kotlin 의 코루틴은 runBlocking 을 사용할 경우를 제외하고는  Java 의 ThreadLocal 을 이용해 스레드 레벨에서의 Context 공유는 불가능합니다. 대신 ThreadLocal 을 CoroutineContext 를 통해 표현한 코틀린 버전의 ThreadLocalElement 라는 CoroutineContext 객체가 있기는 합니다.e.g.\npackage io.chagchagchag.demo.kotlin_coroutine.coroutine_context\r\n\r\nimport io.chagchagchag.demo.kotlin_coroutine.helper.logger\r\nimport kotlinx.coroutines.Dispatchers\r\nimport kotlinx.coroutines.launch\r\nimport kotlinx.coroutines.runBlocking\r\n\r\n\r\nfun main(){\r\n  val log = logger()\r\n  \r\n  val isGreen = ThreadLocal<String>()\r\n  isGreen.set(\"Yes\")\r\n\r\n  runBlocking {\r\n    // 1)\r\n    log.info(\"현재 스레드 = {}\", Thread.currentThread().name)\r\n    log.info(\"isGreen == {}\", isGreen.get())\r\n    assert(isGreen.get() != null)\r\n\r\n    // 2)\r\n    launch (Dispatchers.IO){\r\n      log.info(\"현재 스레드 = {}\", Thread.currentThread().name)\r\n      log.info(\"isGreen = {}\", isGreen.get())\r\n      assert(isGreen.get() == null)\r\n    }\r\n  }\r\n  \r\n}\n출력결과\n20:34:55.017 [main] INFO io.chagchagchag.demo.kotlin_coroutine.helper.LoggerDump -- 현재 스레드 = main\r\n20:34:55.021 [main] INFO io.chagchagchag.demo.kotlin_coroutine.helper.LoggerDump -- isGreen == Yes\r\n20:34:55.037 [DefaultDispatcher-worker-1] INFO io.chagchagchag.demo.kotlin_coroutine.helper.LoggerDump -- 현재 스레드 = DefaultDispatcher-worker-1\r\n20:34:55.038 [DefaultDispatcher-worker-1] INFO io.chagchagchag.demo.kotlin_coroutine.helper.LoggerDump -- isGreen = null\n1) 과 2) 에서 각각 사용된 스레드가 다르다는 것을 확인 가능합니다.1)\n1) 에서 호출한 결과는 ThreadLocal 의 변수를 제대로 가져옵니다.\n그리고 현재 스레드의 이름을 출력해본 결과 main 으로 나타납니다.\nrunBlocking 이라는 코루틴 빌더는 main 스레드에서 실행되기 때문에 ThreadLocal 을 사용가능하고, main 스레드에서 실행할 수 있습니다.\n하지만 블로킹 방식이라는 점에 주의해야 합니다.\n2)\n2) 에서 호출한 결과는 main 클래스에서 선언한 ThreadLocal 변수의 값을 가져오지 못합니다.\nmain 스레드에서 실행되는 것이 아니기 때문입니다.\nlaunch, async 같은 suspend 함수들은 main 스레드에서 실행되지 않고 코루틴에서 실행됩니다.\n코루틴은 내부적으로 다른 스레드에서 실행되고 코루틴 자신이 실행될 스레드 역시 CoroutineDispatcher 에 의해 바뀔 때도 있습니다. 따라서 ThreadLocal 변수를 공유하는 것이 불가능에 가깝습니다.","suspend-함수-내에서-coroutinecontext-를-어떻게-접근하나요#suspend 함수 내에서 CoroutineContext 를 어떻게 접근하나요?":"suspend 키워드가 적용된 함수 내에서는 coroutineContext 라는 변수에 접근 가능합니다.\npackage io.chagchagchag.demo.kotlin_coroutine.coroutine_context\r\n\r\nimport io.chagchagchag.demo.kotlin_coroutine.helper.logger\r\nimport kotlinx.coroutines.runBlocking\r\nimport kotlin.coroutines.coroutineContext\r\nimport kotlin.coroutines.resume\r\nimport kotlin.coroutines.suspendCoroutine\r\n\r\nfun main(){\r\n  val log = logger()\r\n    \r\n  // (1)\r\n  runBlocking {\r\n    log.info(\"현재 코루틴 스코프 내의 코루틴 컨텍스트 : ${this.coroutineContext}\")\r\n    inner() // 다른 함수를 호출할 때 어떻게 되는지 확인해봅니다.\r\n  }\r\n}\r\n\r\nprivate suspend fun inner(){\r\n  val log = logger()\r\n  // (2)\r\n  log.info(\"suspend 함수 내에서의 context ${coroutineContext}\")\r\n\r\n  // (3)\r\n  var result = suspendCoroutine<String> { continuation ->\r\n    log.info(\"Continuation 객체 내의 context = ${continuation.context}\")\r\n    continuation.resume(\"OK\")\r\n  }\r\n    \r\n  // (4)\r\n  log.info(\"inner 함수 내애서의 result = $result\")\r\n}\n(1)\n(1) 에서는 runBlocking{...} 함수 내에서 코루틴 컨텍스트에 접근하는데, coroutineContext 변수로 접근했다는 것을 알 수 있습니다. runBlocking 함수의 마지막 인자는 람다인데, 이 람다 내에서 coroutineContext 필드를 접근하고 있는 것을 알 수 있습니다.\n(2)\n(2) 에서는 일반 suspend 함수에서 coroutineContext 에 접근하는 것을 보여줍니다. suspend 함수 내에서는 단순히 coroutineContext 필드를 사용해서 코루틴 컨텍스트데 접근 가능합니다.\n(3)\n(3) 에서는 suspendCoroutine 함수를 실행하고 있는데, suspendCoroutine 함수의 마지막인자인 람다를 이용하고 있습니다. 이 람다의 첫번째 인자는 continuation 타입인데, 이 continuation 타입 내의 context 필드를 통해서 CoroutineContext 필드에 접근이 가능합니다.\n(4)\nsuspendCoroutine 이 반환한 result 값을 받아서 확인해보니 정상적으로 돌려받았습니다. suspend 함수를 동기연산처럼 사용했습니다.\n위의 코드에 대한 출력결과는 아래와 같습니다.\n21:37:30.203 [main] INFO io.chagchagchag.demo.kotlin_coroutine.helper.LoggingObject -- 현재 코루틴 스코프 내의 코루틴 컨텍스트 : [BlockingCoroutine{Active}@5ec0a365, BlockingEventLoop@4fe3c938]\r\n21:37:30.210 [main] INFO io.chagchagchag.demo.kotlin_coroutine.helper.LoggingObject -- suspend 함수 내에서의 context [BlockingCoroutine{Active}@5ec0a365, BlockingEventLoop@4fe3c938]\r\n21:37:30.213 [main] INFO io.chagchagchag.demo.kotlin_coroutine.helper.LoggingObject -- Continuation 객체 내의 context = [BlockingCoroutine{Active}@5ec0a365, BlockingEventLoop@4fe3c938]\r\n21:37:30.213 [main] INFO io.chagchagchag.demo.kotlin_coroutine.helper.LoggingObject -- inner 함수 내애서의 result = OK","async-launch-등의-코루틴-빌더는-왜--으로-끝나나요#async, launch 등의 코루틴 빌더는 왜 {} 으로 끝나나요?":"async 함수를 예로 들어보겠습니다. kotlin-coroutines-core 라이브러리에서 제공하는  Builders.common.kt 파일 내의 async 함수는 아래와 같이 정의되어 있습니다.마지막 인자는 suspend CoroutineScope.() -> T 와 같이 선언되어 람다로 선언되어 있음을 확인 가능합니다.코틀린 문법을 정리하면서 자세히 정리하겠지만, 코틀린에서는 함수의 마지막인자가 람다일 경우 () 으로 감싸지 않고 { } 으로 끝낼 수 있습니다. 위의 코드에서는 세개의 인자들 중 context, start 는 모두 디폴트 값이 정해져 있고, 마지막 인자는 람다입니다. 따라서 async (...) 함수를 호출할 때에는  아래와 같은 식으로 표현하는 것이 가능해집니다.\nfun main(){\r\n    async{ // 여기부터 있는 람다 바디는 사실 async() 함수의 마지막 인자에요!!\r\n        println(\"안뇽하세요\")\r\n    }\r\n}\n그리고 kotlin-coroutine-core 에서 제공하는 async, launch, withContext 등과 같은 코루틴과 관련된 함수들을 코루틴 빌더라고 부릅니다."}},"/coroutine-dispatcher/intro":{"title":"Intro","data":{}},"/coroutine-scope-and-structured-concurrency/coroutine-scope-builders":{"title":"Coroutine Scope Builders","data":{"coroutinescope-빌더-함수들#CoroutineScope 빌더 함수들":"","coroutinescope-빌더-함수들의-종류#CoroutineScope 빌더 함수들의 종류":"kotlin-coroutine-core 에서 제공하는 CoroutineScope 를 생성하는 함수들은 아래와 같습니다. CoroutineScope.kt 파일 내에 CoroutineScope 인터페이스의 확장함수로 추가되어있기도 하고, Buidlers.common.kt 내에 함수로 선언되어 있는 경우도 있습니다. 이 함수들을 주로 코루틴 빌더 라고 부르기도 합니다.\nwithContext : 코루틴 컨텍스트를 변경하는 함수입니다. 다른 스레드에서 코드를 실행하거나, 특정 디스패처에 작업을 보내는 것이 가능합니다.\ndelay : 일정 시간 동안 코루틴을 일시 중단하는 함수입니다. 주로 테스트나 간단한 딜레이를 구현할 때 사용됩니다.\nasync: 비동기 작업의 결과를 반환하는 코루틴을 생성합니다. 생성된 코루틴은 Deferred 객체를 반환하며, 이를 통해 결과를 가져올 수 있습니다.\nawait: Deferred 객체의 결과를 기다리는 함수로, async 함수로 생성된 Deferred 객체의 결과를 가져올 때 사용됩니다.\nlaunch: 백그라운드에서 비동기적으로 새로운 코루틴을 실행하는 함수로, 반환 값이 없는 Fire-and-forget 스타일의 코루틴을 생성합니다.\nrunBlocking: 새로운 블록 내에서 코루틴을 실행하는 함수로, 주로 메인 함수나 테스트 코드에서 사용되며, 코루틴을 기다리는 동안 블로킹을 유지합니다.\ncoroutineScope: 지정된 블록 내에서 새로운 코루틴 스코프를 생성하는 함수로, 지정된 블록 내의 코루틴이 완료될 때까지 대기합니다.\nselect: 여러 개의 중단 가능한 조건을 동시에 처리할 수 있는 함수로, 먼저 발생하는 이벤트를 처리하고 나머지는 무시합니다.\nsupervisorScope: 자식 코루틴이 실패하더라도 부모 코루틴이 중단되지 않도록 하는 슈퍼바이저 스코프를 생성하는 함수로, 자식 코루틴의 실패를 격리합니다.\n이 함수들은 보통 마지막 인자를 람다식으로 받는데, 가장 마지막 인자가 람다식 일 경우 아래와 같이 축약해서 쓰는 것이 가능합니다.\nlaunch{\r\n    // ...\r\n}\n우리가 흔히 보는 launch 구문, withContext 구문, async 구문 등은 모두 마지막 인자가 람다식입니다.","coroutinescope-빌더-함수들-1#CoroutineScope 빌더 함수들":"","launch#launch":"참고 : CoroutineScope.launch\nlaunch 의 마지막 인자인 람다는 Unit 을 반환하기에 launch 내에서 값을 반환할 필요가 없습니다.그리고 launch {...} 코루틴 빌더는 Job 을 리턴합니다.\nfun CoroutineScope.launch(\r\n    context: CoroutineContext = EmptyCoroutineContext, \r\n    start: CoroutineStart = CoroutineStart.DEFAULT, \r\n    block: suspend CoroutineScope.() -> Unit\r\n): Job","async#async":"참고 : CoroutineScope.async\nasync 의 마지막 인자인 람다는 T 를 리턴합니다. 따라서 async 내에서 값을 반환해야 합니다. 반환값이 필요한 경우에 async 를 사용하면 됩니다.\nfun <T> CoroutineScope.async(\r\n    context: CoroutineContext = EmptyCoroutineContext, \r\n    start: CoroutineStart = CoroutineStart.DEFAULT, \r\n    block: suspend CoroutineScope.() -> T\r\n): Deferred<T>","withcontext#withContext":"참고 : withContext\nsuspend fun <T> withContext(context: CoroutineContext, block: suspend CoroutineScope.() -> T): T"}},"/coroutine-scope-and-structured-concurrency/intro":{"title":"Intro","data":{}},"/coroutine-dispatcher/what-is-coroutine-dispatcher":{"title":"What Is Coroutine Dispatcher","data":{"coroutinedispatcher#CoroutineDispatcher":"Coroutine 은 스레드 내에서 실행되며 특정 Coroutine 이 실행중에 IO 요청을 수행하고 응답을 대기 중 일때 코루틴은 중단됩니다. 코루틴이 중단되었을 때 코틀린은 뒷단에서 다른 코루틴을 수행합니다. 그리고 IO 요청에 대한 응답이 와서 처리를 해야 할 때 코루틴은 다시 재개되는데, 이때 재개되는 코루틴은 원래 IO요청을 수행했던 스레드가 아닌 다른 스레드에서 실행될 수도 있습니다.이렇게 코루틴이 작업을 중단하고 다시 재개할 때 어떤 스레드에서 실행될지를 결정하는 역할을 하는 것은 코루틴 디스패처(CoroutineDispatcher)입니다. 코루틴 디스패처는 코루틴을 어떤 스레드에서 분배할지를 효율적으로 결정하는 역할을 합니다.즉, 코틀린의 코루틴은 스레드 하나에서만 작업이 쭉 이뤄지지는 않습니다. 그리고 코루틴이 실행될 스레드를 결정하는 것은 코루틴 디스패처(CoroutineDispatcher) 입니다.","thread-개수의-의미#Thread 개수의 의미":"일반적으로 Thread 하나를 CPU 하나로 비유하는 경우가 있습니다. 이렇게 비유하는 경우는 CPU 중심의 복잡한 연산을 하는 경우에 적합합니다.일반적인 애플리케이션의 경우 외부 API 요청/응답, Database 접근 등의 연산이 수행됩니다.이 과정에서 요청을 한 후 응답을 기다리는 놀고 있는 유휴 대기 시간이 많이 생깁니다.이런 이유로 실무에서 스레드 프로그램을 작성할 때는 IO 작업의 개수가 100개 이더라도 3개 정도의 스레드를 Sheduler 를 이용해서 작업을 스케쥴링해서 운영하는 경우가 많습니다. 즉, 모든 스레드가 1개의 CPU를 온전히 점유하는 것이 아니라 시분할을 통해 CPU 타임을 할당하는 방식입니다.쿠버네티스에서도 CPU에 CPU Time 을 정의합니다. 예를 들어 CPU 에 대해 1000m 을 지정하면 운영체제에 1초에 CPU 1개 만큼의 시간을 부여받겠다고 요청하는 의미를 가집니다. AI 계산, 수식 계산 등과 같은 작업이 아닌 I/O 작업을 수행하는 서버 애플리케이션의 경우 1초에 CPU 한개를 온전히 소유한다는 것은 굉장히 비싼 축에 속합니다.이런 이유로 CPU Time 은 일반적으로 250m 과 같이 1초에 0.25 만큼의 CPU 정도를 쓰겠다. 이런 설정을 부여합니다.이 글을 읽을 때는 Thread 하나로 작업을 수행한다고 해서 온전히 CPU 하나를 의미한다고 생각하지 않으셨으면 합니다.","coroutinedispatcher-의-종류#CoroutineDispatcher 의 종류":"코루틴에서 제공하는 대표적인 CoroutineDispatcher 는 Default, IO, Unconfined, Main 이 있습니다.\nDispatchers.Default\nDispatchers.IO\nDispatchers.Unconfined\nDispatchers.Main\n이 중 Dispatchers.Main 은 안드로이드에서만 지원하는 코루틴 디스패처입니다. 따라서 이번 문서에서는 Dispatchers.Main 은 정리하지 않습니다.","dispatchersdefault#Dispatchers.Default":"참고 : Dispatchers.Default, code : Dispatchers.common.kt\nDispatchers.Default 는 CPU 코어 개수 만큼의 크기의 스레드 풀을 갖는 CoroutineDispatcher 입니다. 만약 CoroutineDispatcher 를 별도로 지정하지 않고 코루틴을 사용하려 한다면 Dispatchers.Default 를 기본으로 사용하게 됩니다.Dispatchers.Default는 CPU 개수 만큼의 고정된 풀을 사용하기에, 가급적 계산작업의 비중이 높은 CPU 위주의 블로킹연산에 사용하는 것이 좋습니다.","eg#e.g.":"package io.chagchagchag.demo.kotlin_coroutine.coroutine_dispatcher\r\n\r\nimport io.chagchagchag.demo.kotlin_coroutine.helper.logger\r\nimport kotlinx.coroutines.CoroutineDispatcher\r\nimport kotlinx.coroutines.Dispatchers\r\nimport kotlinx.coroutines.runBlocking\r\nimport kotlinx.coroutines.withContext\r\n\r\n@OptIn(ExperimentalStdlibApi::class)\r\nfun main(){\r\n  val log = logger()\r\n\r\n  runBlocking {\r\n    // (1)\r\n    log.info(\"스레드 == ${Thread.currentThread().name}\")\r\n    log.info(\"디스패처 == ${this.coroutineContext[CoroutineDispatcher.Key]}\")\r\n\r\n    // (2)\r\n    withContext(Dispatchers.Default){\r\n      log.info(\"스레드 == ${Thread.currentThread().name}\")\r\n      log.info(\"디스패처 == ${this.coroutineContext[CoroutineDispatcher.Key]}\")\r\n    }\r\n  }\r\n}\r\n(1)\nmain() 내에서 runBlocking 을 했습니다. runBlocking 은 main 스레드의 코루틴 컨텍스트를 그대로 사용하기에 출력결과에서도 스레드 == main 라고 나타납니다.\nrunBlocking 을 호출한 디스패처를 보면 디스패처 == BlockingEventLoop@13a5fe33 가 나타납니다.\ndelay 함수를 사용하지 않고 모든 예제를 main 문과 Dispatchers.Default 기반의 코루틴의 스레드 명을 비교하기 위해 runBlocking{...} 을 사용했습니다.\n(2)\nwithContext(Dispatchers.Default){...} 을 통해 Dispatchers.Default 에서 코루틴을 실행하면, 스레드 == DefaultDispatcher-worker-1 와 같이 출력결과가 나타난 것으로 보아 내부적으로 CoroutineDispatcher 는 DefaultDispatcher-worker-1 라는 스레드를 할당했음을 알 수 있습니다.\n출력결과로 디스패처 == Dispatchers.Default 가 나타났고,  runBlocking 을 관리하는 코루틴 디스패처와  withContext 컨텍스트를 실행한 디스패처가 다르다는 것을 확인 가능합니다.\n출력결과\n18:23:51.714 [main] INFO io...helper.LoggingObject -- 스레드 == main\r\n18:23:51.721 [main] INFO io...helper.LoggingObject -- 디스패처 == BlockingEventLoop@13a5fe33\r\n18:23:51.758 [DefaultDispatcher-worker-1] INFO io...helper.LoggingObject -- 스레드 == DefaultDispatcher-worker-1\r\n18:23:51.759 [DefaultDispatcher-worker-1] INFO io...helper.LoggingObject -- 디스패처 == Dispatchers.Default\r\n\r\nProcess finished with exit code 0","dispatchersio#Dispatchers.IO":"참고 : Dispatchers.IO, code : Dispatchers.kt\n현실세계에서의 서버를 이용한 작업은 대부분 CPU 작업보다는 IO 작업이 많습니다. 외부 API 를 요청해서 결제를 수행한다거나, 데이터를 조회하거나 인증을 수행하는 등 여러가지 요청을 보내고 나서 응답을 받기 전까지의 블로킹이 발생합니다.따라서 IO 작업 하나에 스레드 하나를 온전히 할당하는 것은 굉장히 큰 낭비가 됩니다. IO 요청이 끝날 때 까지 블로킹되는 대신 응답이 오기 전까지는 다른 작업을 수행하도록 해서 스레드 하나를 여러 작업으로 나눠서 수행하는 것이 중요합니다.Dispatchers.IO 는 이렇게 blocking I/O 기반의 작업을 수행하기에 적절하도록 코틀린 코루틴에서 제공하는 코루틴 디스패처입니다. 내부적으로는 최대 64개의 스레드까지 가질수 있으며, 스레드 풀은 가변적으로 운영됩니다.","eg-1#e.g.":"package io.chagchagchag.demo.kotlin_coroutine.coroutine_dispatcher\r\n\r\nimport io.chagchagchag.demo.kotlin_coroutine.helper.logger\r\nimport kotlinx.coroutines.CoroutineDispatcher\r\nimport kotlinx.coroutines.Dispatchers\r\nimport kotlinx.coroutines.runBlocking\r\nimport kotlinx.coroutines.withContext\r\n\r\n@OptIn(ExperimentalStdlibApi::class)\r\nfun main(){\r\n  val log = logger()\r\n\r\n  runBlocking {\r\n    // (1)\r\n    log.info(\"스레드 == ${Thread.currentThread().name}\")\r\n    log.info(\"디스패처 == ${this.coroutineContext[CoroutineDispatcher]}\")\r\n\r\n    // (2)\r\n    withContext(Dispatchers.IO){\r\n      log.info(\"스레드 == ${Thread.currentThread().name}\")\r\n      log.info(\"디스패처 == ${this.coroutineContext[CoroutineDispatcher]}\")\r\n    }\r\n  }\r\n}\n(1)\nmain() 내에서 runBlocking 을 했습니다. runBlocking 은 main 스레드의 코루틴 컨텍스트를 그대로 사용하기에 출력결과에서도 스레드 == main 라고 나타납니다.\nrunBlocking 을 호출한 디스패처를 보면 디스패처 == BlockingEventLoop@13a5fe33 가 나타납니다.\ndelay 함수를 사용하지 않고 모든 예제를 main 문과 Dispatchers.Default 기반의 코루틴의 스레드 명을 비교하기 위해 runBlocking{...} 을 사용했습니다.\n(2)\nwithContext(Dispatchers.Default){...} 을 통해 Dispatchers.Default 에서 코루틴을 실행하면, 스레드 == DefaultDispatcher-worker-1 와 같이 출력결과가 나타난 것으로 보아 내부적으로 CoroutineDispatcher 는 DefaultDispatcher-worker-1 라는 스레드를 할당했음을 알 수 있습니다.\n출력결과로 디스패처 == Dispatchers.IO 가 나타났고,  runBlocking 을 관리하는 코루틴 디스패처와  withContext 컨텍스트를 실행한 디스패처가 다르다는 것을 확인 가능합니다.\n출력결과\n18:32:05.176 [main] INFO io...helper.LoggingObject -- 스레드 == main\r\n18:32:05.186 [main] INFO io...helper.LoggingObject -- 디스패처 == BlockingEventLoop@13a5fe33\r\n18:32:05.214 [DefaultDispatcher-worker-1] INFO io...helper.LoggingObject -- 스레드 == DefaultDispatcher-worker-1\r\n18:32:05.214 [DefaultDispatcher-worker-1] INFO io...helper.LoggingObject -- 디스패처 == Dispatchers.IO\r\n\r\nProcess finished with exit code 0","dispatchersunconfined#Dispatchers.Unconfined":"참고\nDispatchers.Unconfined, code : Dispatchers.common.kt\nCoroutine Dispatchers 1편\nUnconfined 디스패처는 특정 스레드에 제한되지 않는 코루틴 디스패처입니다. suspend 함수를 재개할 때에 스레드를 사용하는 스레드 정책이 따로 마련되어 있지 않는 방식으로 스레드를 분배합니다. Undefined 디스패처는 중첩 코루틴 실행시에 호출 프레임의 스택오버플로우를 방지하기 위해서 이벤트 루프를 구성합니다.처음 코루틴을 실행할 때에는 이 코루틴을 실행하기 위해 동작하는 스레드 위에서 호출됩니다. 예를 들면 main() 에서 실행한다면 main 스레드에서 코루틴이 실행됩니다.그리고 중지된 코루틴을 재개할 때에는 이 중지된 코루틴을 재개를 시작하는 스레드가 이 코루틴의 작업을 재개시킵니다.쉽게 이야기하면 Dispatchers.Unconfined 는 자신이 실행될 스레드의 종류를 바꿔가면서 무작위로 실행됨을 확인 가능합니다.Dispatchers.Unconfined 코루틴 디스패처는 스레드가 예측이 불가능해서 일반적인 코드에서 사용하지 않도록 권장하는 편입니다.스프링 컨트롤러에서는 Dispatchers.Unconfined 기반으로 suspend 함수의 처리를 지원합니다. 아마도 컨트롤러의 요청 처리 방식의 특성 상 호출 프레임에 따라서 호출했던 스레드가 처리를 하기보다는 이벤트 루프 기반으로 수행하는 것이 스택오버플로우 현상을 방지할  수 있기에 이렇게 설정한 것으로 보입니다.","eg-2#e.g.":"package io.chagchagchag.demo.kotlin_coroutine.coroutine_dispatcher\r\n\r\nimport io.chagchagchag.demo.kotlin_coroutine.helper.logger\r\nimport kotlinx.coroutines.*\r\n\r\nfun main(){\r\n  val log = logger()\r\n\r\n  runBlocking {\r\n    launch(Dispatchers.Unconfined) {\r\n      // (1)\r\n      log.info(\"(1) at Unconfined, Thread Name = ${Thread.currentThread().name}\")\r\n\r\n      withContext(Dispatchers.IO){\r\n        // (2)\r\n        log.info(\"(2) at Dispatchers.IO, Thread Name = ${Thread.currentThread().name}\")\r\n      }\r\n\r\n      // (3)\r\n      log.info(\"(3) at Unconfined, Thread Name = ${Thread.currentThread().name}\")\r\n      delay(1500)\r\n      \r\n      // (4)\r\n      log.info(\"(4) at Unconfined, ThreadName = ${Thread.currentThread().name}\")\r\n    }\r\n  }\r\n}\n(1)\nDispatchers.Unconfined 내에서 스레드 명을 찍어봅니다.\n결과는 Thread Name = main 으로 나타납니다. Unconfined 코루틴 디스패처가 main 스레드를 할당했음을 알 수 있습니다.\n(2)\nDispatchers.IO 내에서 스레드 명을 찍어봅니다.\n결과는 Thread Name = DefaultDispatcher-worker-1 으로 나타납니다. Unconfined 코루틴 디스패처가 실행한 Dispatcher.IO 코루틴 컨텍스트에서는 Dispatchers.IO 코루틴 디스패처가 적용되었음을 유추 가능합니다.\n(3)\nDispatchers.Unconfined 로 다시 돌아와서 스레드 명을 찍어봅니다.\n결과는 Thread Name = DefaultDispatcher-worker-1 으로 나타납니다. 현재 블록이 Dispatchers.Unconfined 컨텍스트의 영역임에도 이전 컨텍스트가 수행하던 디스패처인 Thread Name = DefaultDispatcher-worker-1 에서 실행하고 있는 것을 확인 가능합니다.\n(4)\n스레드가 일정시간이 지나면 회수되는지 확인을 위해 1.5초 정도 delay 를 한 후에 Dispatchers.Unconfined 영역에서의 스레드가 다시 재배치 되었는지 확인해봅니다.\n결과는 ThreadName = kotlinx.coroutines.DefaultExecutor 으로 나타납니다. Dispatchers.Unconfined 는 자신이 실행될 스레드의 종류를 바꿔가면서 무작위로 실행됨을 확인 가능합니다.\n출력결과\n19:16:58.859 [main] INFO io...helper.LoggingObject -- (1) at Unconfined, Thread Name = main\r\n19:16:58.899 [DefaultDispatcher-worker-1] INFO io...helper.LoggingObject -- (2) at Dispatchers.IO, Thread Name = DefaultDispatcher-worker-1\r\n19:16:58.899 [DefaultDispatcher-worker-1] INFO io...helper.LoggingObject -- (3) at Unconfined, Thread Name = DefaultDispatcher-worker-1\r\n19:17:00.426 [kotlinx.coroutines.DefaultExecutor] INFO io...helper.LoggingObject -- (4) at Unconfined, ThreadName = kotlinx.coroutines.DefaultExecutor\r\n\r\nProcess finished with exit code 0","dispatchersmain#Dispatchers.Main":"Dispatchers.Main 은 안드로이드에서만 지원하는 코루틴 디스패처입니다. 따라서 이번 문서에서는 Dispatchers.Main 은 정리하지 않습니다.","dispatchersio-와-dispatchersdefault#Dispatchers.IO 와 Dispatchers.Default":"Dispatchers.IO와 Dispatchers.Default 는 스레드 풀을 공유합니다.","eg-1-#e.g. 1 :":"package io.chagchagchag.demo.kotlin_coroutine.coroutine_dispatcher\r\n\r\nimport io.chagchagchag.demo.kotlin_coroutine.helper.logger\r\nimport kotlinx.coroutines.*\r\n\r\n@OptIn(ExperimentalStdlibApi::class)\r\nfun main(){\r\n  val log = logger()\r\n\r\n  runBlocking {\r\n    // (1)\r\n    log.info(\"스레드 == ${Thread.currentThread().name}\")\r\n    log.info(\"디스패처 == ${this.coroutineContext[CoroutineDispatcher.Key]}\")\r\n\r\n    // (2)\r\n    withContext(Dispatchers.Default){\r\n      log.info(\"스레드 == ${Thread.currentThread().name}\")\r\n      log.info(\"디스패처 == ${this.coroutineContext[CoroutineDispatcher.Key]}\")\r\n    }\r\n\r\n    // (3)\r\n    withContext(Dispatchers.IO){\r\n      log.info(\"스레드 == ${Thread.currentThread().name}\")\r\n      log.info(\"디스패처 == ${this.coroutineContext[CoroutineDispatcher.Key]}\")\r\n    }\r\n\r\n    // (4)\r\n    CoroutineScope(CoroutineName(\"배고파요\")).launch {\r\n      log.info(\"스레드 == ${Thread.currentThread().name}\")\r\n      log.info(\"디스패처 == ${this.coroutineContext[CoroutineDispatcher.Key]}\")\r\n    }\r\n  }\r\n}\n(1)\nmain 스레드 안에서 스레드 명, CoroutineDispatcher 를 출력해봅니다.\n출력결과는 스레드는 main 으로, 디스패처는 BlockingEventLoop@13a5fe33 이 출력됩니다. runBlocking 내의 코루틴 디스패처를 접근했기 때문에 BlockingEventLoop@13a5fe33 이 조회되었습니다.\n(2)\nDispatchers.Default 코루틴 컨텍스트 안에서 스레드명, CoroutineDispatcher 를 출력해봅니다.\n출력결과는 스레드는 DefaultDispatcher-worker-1 으로, 디스패처는 Dispatchers.Default 으로 나타났습니다.\n(3)\nDispatchers.IO 코루틴 컨텍스트 안에서 스레드명, CoroutineDispatcher 를 출력해봅니다.\n출력결과는 스레드는 DefaultDispatcher-worker-1 으로, 디스패처는 Dispatchers.IO 로 나타났습니다.\n(4)\n코루틴 디스패처를 별도로 명시하지 않은 코루틴 컨텍스트 안에서 스레드명, CoroutineDispatcher 를 출력해봅니다.\n출력결과는 스레드는 DefaultDispatcher-worker-1 으로, 디스패처는 Dispatchers.Default 으로 나타났습니다.\n출력결과\n19:32:50.451 [main] INFO io...helper.LoggingObject -- 스레드 == main\r\n19:32:50.458 [main] INFO io...helper.LoggingObject -- 디스패처 == BlockingEventLoop@13a5fe33\r\n19:32:50.498 [DefaultDispatcher-worker-1] INFO io...helper.LoggingObject -- 스레드 == DefaultDispatcher-worker-1\r\n19:32:50.499 [DefaultDispatcher-worker-1] INFO io...helper.LoggingObject -- 디스패처 == Dispatchers.Default\r\n19:32:50.507 [DefaultDispatcher-worker-1] INFO io...helper.LoggingObject -- 스레드 == DefaultDispatcher-worker-1\r\n19:32:50.508 [DefaultDispatcher-worker-1] INFO io...helper.LoggingObject -- 디스패처 == Dispatchers.IO\r\n19:32:50.522 [DefaultDispatcher-worker-1] INFO io...helper.LoggingObject -- 스레드 == DefaultDispatcher-worker-1\r\n19:32:50.523 [DefaultDispatcher-worker-1] INFO io...helper.LoggingObject -- 디스패처 == Dispatchers.Default\r\n\r\nProcess finished with exit code 0","eg-2--dispatchersio-dispatchersdefault-의-스레드-공유-예제#e.g. 2 : Dispatchers.IO, Dispatchers.Default 의 스레드 공유 예제":"이번에는 아래 예제 처럼 비교적 큰 수인 2000 개의 작업을 launch 를 통해서 코루틴을 수행하면 worker 스레드가 64개 이상으로 늘어나고, 출력결과를 보면 모두 DefaultDispatcher-worker-x 와 같은 포맷으로 출력됨을 확인할 수 있습니다.\npackage io.chagchagchag.demo.kotlin_coroutine.coroutine_dispatcher\r\n\r\nimport io.chagchagchag.demo.kotlin_coroutine.helper.logger\r\nimport kotlinx.coroutines.Dispatchers\r\nimport kotlinx.coroutines.launch\r\nimport kotlinx.coroutines.runBlocking\r\n\r\n\r\nfun main (){\r\n  val log = logger()\r\n\r\n  runBlocking {\r\n    for(i in 1 until 2000){\r\n      launch (Dispatchers.Default){\r\n        log.info(\"현재 스레드 : ${Thread.currentThread().name}\")\r\n      }\r\n\r\n      launch (Dispatchers.IO){\r\n        log.info(\"현재 스레드 : ${Thread.currentThread().name}\")\r\n      }\r\n    }\r\n  }\r\n}","executorcoroutinedispatcher#ExecutorCoroutineDispatcher":"Dispatchers.Default 는 너무 CPU Bound 작업에 특화되어 있고, Dispatchers.IO 는 너무 스레드 자원을 크게 사용한다는 느낌이 들 때가 있습니다. 스레드 풀을 조금 더 경량화 해서 잡을 수도 있을 것 같고, 더 효율적으로 스레드를 사용하도록 스케쥴링 기반으로 전환할 수도 있습니다.이런 경우 ExecutorCoroutineDispatcher 를 사용해서 원하는 커스텀 설정이 적용된 CoroutineDispatcher를 만들어낼 수 있습니다.ExecutorCoroutineDispatcher 를 사용하면 특정 크기의 스레드 풀을 갖는 Dispatcher 를 생성 가능하고 직접 설정한 Executor를 주입해서 사용 가능합니다.만약 저라면 ExecutorCoroutineDispatcher 를 용도별로 분류해서 적극적으로 활용하지 않을까 싶습니다.","eg-3#e.g.":""}},"/coroutine-scope-and-structured-concurrency/structured-concurrency":{"title":"Structured Concurrency","data":{"structured-concurrency#Structured Concurrency":"async, launch 와 같은 코루틴 빌더 함수를 사용할 때 각각의 비동기 식의 순서를 조율해야 할 경우가 있고 동기적으로 수행해야 할 경우가 있습니다. 이 경우 가장 원초적인 방법으로는 중첩된 스코프에서 식을 실행하는 방법이 있습니다. 하지만, 중첩된 스코프가 복잡해지면, 고치기도 어렵고 읽기도 어려워지며 유지보수가 어려워지게 됩니다.이런 경우 조금 더 깔끔한 방법으로 동기연산으로 정의되어 있는 coroutineContext() 빌더 함수, withContext() 빌더 함수를 사용해서 해결합니다.\ncoroutineContext() 코루틴 스코프 빌더 함수\nwithContext() 코루틴 스코프 빌더 함수\n이번 문서에서는 대부분의 예제를 coroutineContext() 코루틴 스코프 빌더 함수를 사용하는 방식을 설명했는데, 가장 마지막 챕터에 withContext() 를 사용하는 경우 역시 예제로 정리해두었습니다.","structured-concurrency-란#Structured Concurrency 란?":"lanch{...}, async{...} 등과 같은 코루틴 빌더를 사용할 때 이 것을 중첩되어서 사용하는 경우가 있을 수 있습니다. 이렇게 중첩해서 lanch{...}, async{...} 을 사용하는 것을 보통 Structured Concurrency 라고 합니다. 예를 들면 아래와 같은 코드를 Structured Concurrency 라고 이야기합니다.\npackage io.chagchagchag.demo.kotlin_coroutine.structured_concurrency\r\n\r\nimport io.chagchagchag.demo.kotlin_coroutine.helper.logger\r\nimport kotlinx.coroutines.*\r\nimport kotlin.coroutines.EmptyCoroutineContext\r\n\r\nfun main(){\r\n  val log = logger()\r\n\r\n  runBlocking {\r\n    val job = CoroutineScope(EmptyCoroutineContext).launch {\r\n      // ----- (1)\r\n      val applePrice = async {\r\n        delay(1000)\r\n        5000\r\n      }\r\n      val bananaPrice = async {\r\n        delay(1000)\r\n        7000\r\n      }\r\n      val carrotPrice = async {\r\n        delay(1000)\r\n        3000\r\n      }\r\n\r\n      log.info(\"(1)\")\r\n      val sum = applePrice.await() + bananaPrice.await() + carrotPrice.await()\r\n      // ----- (1)\r\n      log.info(\"sum = $sum\")\r\n      log.info(\"(2)\")\r\n      assert(sum == 5000 + 7000 + 3000)\r\n    }\r\n\r\n    job.join() // join() 하지 않으면 main 문은 자기 마음대로 끝냅니다.\r\n  }\r\n}\n그런데 이렇게 중첩된 CoroutineScope 들을 특정 순서에 맞춰서 호출되게끔 해야 하는 경우가 있습니다. 일반적으로 간단한 코드의 경우 launch{} 를 사용할 경우에는 join() 함수를 사용해서 동기코드처럼 작성하고 async{} 를 사용할 경우에는 await() 함수를 사용해서 동기코드 처럼 사용할 수 있습니다.그런데 join(), await() 같은 함수를 직접 작성해서 수행하다보면 가독성이 떨어지기도 하고 코드가 길어지면 실수가 생기기도 하고, for 문 내에서 실행할 경우 동기적으로 실행이 되지 않을 수 있습니다.이 경우 일반적으로 아래와 같은 방식으로 해결할 수 있습니다.\n부모역할의 비동기 스코프 내에 job1, job2, job3, ... 의 작업을 수행하게끔하고 부모 비동기 스코프를 밖에서 join()\ncoroutineScope{...} 또는 withContext(context){...} 내에서 job1, job2, job3, ... 의 작업을 수행하도록 코드를 작성","eg-async#e.g. async":"","복잡한-async-코드#복잡한 async 코드":"아래와 같이 사용하는 async 코드가 있다고 하겠습니다.\npackage io.chagchagchag.demo.kotlin_coroutine.structured_concurrency\r\n\r\nimport io.chagchagchag.demo.kotlin_coroutine.helper.logger\r\nimport kotlinx.coroutines.*\r\nimport kotlin.coroutines.EmptyCoroutineContext\r\n\r\nfun main(){\r\n  val log = logger()\r\n\r\n  runBlocking {\r\n    val job = CoroutineScope(EmptyCoroutineContext).launch {\r\n      // ----- (1)\r\n      val applePrice = async {\r\n        delay(1000)\r\n        5000\r\n      }\r\n      val bananaPrice = async {\r\n        delay(1000)\r\n        7000\r\n      }\r\n      val carrotPrice = async {\r\n        delay(1000)\r\n        3000\r\n      }\r\n\r\n      log.info(\"(1)\")\r\n      val sum = applePrice.await() + bananaPrice.await() + carrotPrice.await()\r\n      // ----- (1)\r\n      log.info(\"sum = $sum\")\r\n      log.info(\"(2)\")\r\n      assert(sum == 5000 + 7000 + 3000)\r\n    }\r\n\r\n    job.join() // join() 하지 않으면 main 문은 자기 마음대로 끝냅니다.\r\n  }\r\n}\n장바구니에 사과, 바나나, 당근이 담겨있고 이것의 가격을 하나씩 모두 호출해 온 후 합산을 해서 현재 장바구니의 주문가격을 계산하는 코드입니다.위의 코드에서 apple.await(), bananaPrice.await(), carrotPrice.await() 을 이용해서 값을 가져와서 합산을 했고, 출력결과를 보면 1초만에 수행이 완료되었습니다. 만약 블로킹 방식의 동기연산으로 수행했으면 3초 걸렸을 작업인데, 각각의 작업을 각각의 코루틴에서 수행되게끔 async{...} 에서 수행했기 때문에 1초만에 수행이 되었습니다.\n출력결과\n11:19:07.202 [DefaultDispatcher-worker-1] INFO io.chagchagchag.demo.kotlin_coroutine.helper.LoggingObject -- (1)\r\n11:19:08.208 [DefaultDispatcher-worker-3] INFO io.chagchagchag.demo.kotlin_coroutine.helper.LoggingObject -- sum = 15000\r\n11:19:08.209 [DefaultDispatcher-worker-3] INFO io.chagchagchag.demo.kotlin_coroutine.helper.LoggingObject -- (2)\r\n\r\nProcess finished with exit code 0\n이 방식의 문제점은 코드가 점점 복잡해진다는 점입니다.// ----- (1) 안에 위치한 코드의 이전이나 이후에 코드를 수행해야 할 경우에는 // ----- (1) 의 위치의 처음과 끝이 어디인지 알아야하고 // ----- (1) 내부의 코드를 다른 함수 등으로 분리해내기 쉽지 않기에 유지보수가 어려워지고, 확장성이 떨어진다는 단점이 있습니다.","원하는-특정-async-코드들의-연산은-coroutinescope-로-감싸기#원하는 특정 async 코드들의 연산은 coroutineScope() 로 감싸기":"이번에는 위의 코드들을 아래와 같이 작성해봅니다.\npackage io.chagchagchag.demo.kotlin_coroutine.structured_concurrency\r\n\r\nimport io.chagchagchag.demo.kotlin_coroutine.helper.logger\r\nimport kotlinx.coroutines.*\r\nimport kotlin.coroutines.EmptyCoroutineContext\r\n\r\nfun main(){\r\n  val log = logger()\r\n\r\n  // ----- (2)\r\n  runBlocking {\r\n    val job = CoroutineScope(EmptyCoroutineContext).launch {\r\n      val cartSum = cartSum1()\r\n      log.info(\"(1)\")\r\n      log.info(\"cartSum = $cartSum\")\r\n      log.info(\"(2)\")\r\n      assert(cartSum == 5000 + 7000 + 3000)\r\n    }\r\n\r\n    job.join() // join() 하지 않으면 main 문은 자기 마음대로 끝냅니다.\r\n  }\r\n}\r\n\r\n// ----- (1)\r\nsuspend fun cartSum1(): Int{\r\n  return coroutineScope {\r\n    val applePrice = async {\r\n      delay(1000)\r\n      5000\r\n    }\r\n    val bananaPrice = async {\r\n      delay(1000)\r\n      7000\r\n    }\r\n    val carrotPrice = async {\r\n      delay(1000)\r\n      3000\r\n    }\r\n\r\n    applePrice.await() + bananaPrice.await() + carrotPrice.await()\r\n  }\r\n}\n// ----- (1)\n사과, 바나나, 당근 가격을 구해오는 async{...} 구문들을 coroutineScope{...} 빌더함수가 생성하는 코루틴 스코프에서 실행하게끔 했습니다. 그리고 반환 값은 applePrice.await() + bananaPrice.await() + carrotPrice.await() 으로 지정해줬습니다.\n// ----- (2)\n처음 async 코드에 비해 단순해졌습니다. 별도의 함수인 cartSum1()에서 합계를 구하도록 했기 때문입니다.\nasync 에 대해 일일이 await() 을 하는 시점을 알고 있을 필요도 없습니다.\n출력결과 역시 원하는 값인 15000이 나왔습니다. 그리고 원하는 대로 1초 내에 연산이 이뤄졌습니다. 만약 모든 작업을 블로킹 기반으로 수행했다면 3초가 걸렸을 것입니다.이렇게 하는 것이 가능한 이유는 coroutineScope{...} 빌더는 동기식 연산을 지원하기 때문입니다. coroutineScope{...} 코드를 보면 블로킹 연산을 수행하는 것이라고 착각할 수 있겠지만, 블로킹연산이 아닌 논블로킹 기반 동기연산을 지원합니다. 코틀린 엔진이coroutineScope{...}의 수행이 끝날 때 까지 뒷단에서는 다른 코루틴을 수행하게 됩니다.출력결과\n11:32:50.036 [DefaultDispatcher-worker-1] INFO io.chagchagchag.demo.kotlin_coroutine.helper.LoggingObject -- (1)\r\n11:32:50.044 [DefaultDispatcher-worker-1] INFO io.chagchagchag.demo.kotlin_coroutine.helper.LoggingObject -- cartSum = 15000\r\n11:32:50.044 [DefaultDispatcher-worker-1] INFO io.chagchagchag.demo.kotlin_coroutine.helper.LoggingObject -- (2)\r\n\r\nProcess finished with exit code 0","eg-launch#e.g. launch":"launch 는 async 와는 다르게 값을 리턴하지 않습니다.","복잡한-launch-코드#복잡한 launch 코드":"아래 코드는 원하는 순서대로 수행됨을 보장하지 않는 launch{...} 를 사용한 코드입니다.\npackage io.chagchagchag.demo.kotlin_coroutine.structured_concurrency\r\n\r\nimport io.chagchagchag.demo.kotlin_coroutine.helper.logger\r\nimport kotlinx.coroutines.CoroutineScope\r\nimport kotlinx.coroutines.delay\r\nimport kotlinx.coroutines.launch\r\nimport kotlinx.coroutines.runBlocking\r\nimport kotlin.coroutines.EmptyCoroutineContext\r\n\r\nfun main(){\r\n  val log = logger()\r\n\r\n  runBlocking {\r\n    val job = CoroutineScope(EmptyCoroutineContext).launch {\r\n      val order = launch {\r\n        delay(1000)\r\n        log.info(\"주문 완료\")\r\n      }\r\n\r\n      val pay = launch {\r\n        delay(1000)\r\n        log.info(\"결제 완료\")\r\n      }\r\n\r\n      val delivery_reservation = launch {\r\n        delay(1000)\r\n        log.info(\"배송 예약 완료\")\r\n      }\r\n\r\n      log.info(\"(1)\")\r\n      order.join()\r\n      pay.join()\r\n      delivery_reservation.join()\r\n      log.info(\"(2)\")\r\n    }\r\n\r\n    job.join()\r\n  }\r\n}\n위 코드의 결과는 아래와 같습니다.원했던 결과는 주문 완료 → 결제 완료 → 배송 예약 완료 인데, 출력결과는 주문 완료 → 배송 예약 완료 → 결제 완료 가 되었습니다.출력결과\n12:01:33.193 [DefaultDispatcher-worker-1] INFO io.chagchagchag.demo.kotlin_coroutine.helper.LoggingObject -- (1)\r\n12:01:34.187 [DefaultDispatcher-worker-1] INFO io.chagchagchag.demo.kotlin_coroutine.helper.LoggingObject -- 주문 완료\r\n12:01:34.198 [DefaultDispatcher-worker-3] INFO io.chagchagchag.demo.kotlin_coroutine.helper.LoggingObject -- 배송 예약 완료\r\n12:01:34.198 [DefaultDispatcher-worker-1] INFO io.chagchagchag.demo.kotlin_coroutine.helper.LoggingObject -- 결제 완료\r\n12:01:34.199 [DefaultDispatcher-worker-1] INFO io.chagchagchag.demo.kotlin_coroutine.helper.LoggingObject -- (2)\r\n\r\nProcess finished with exit code 0\n이번에는 아래와 같은 코드를 작성해봅니다.\npackage io.chagchagchag.demo.kotlin_coroutine.structured_concurrency\r\n\r\nimport io.chagchagchag.demo.kotlin_coroutine.helper.logger\r\nimport kotlinx.coroutines.CoroutineScope\r\nimport kotlinx.coroutines.delay\r\nimport kotlinx.coroutines.launch\r\nimport kotlinx.coroutines.runBlocking\r\nimport kotlin.coroutines.EmptyCoroutineContext\r\n\r\nfun main(){\r\n  val log = logger()\r\n\r\n  runBlocking {\r\n    val job = CoroutineScope(EmptyCoroutineContext).launch {\r\n      val order = launch {\r\n        delay(1000)\r\n        log.info(\"주문 완료\")\r\n\r\n        val pay = launch {\r\n          delay(1000)\r\n          log.info(\"결제 완료\")\r\n\r\n          val delivery_reservation = launch {\r\n            delay(1000)\r\n            log.info(\"배송 예약 완료\")\r\n          }\r\n          delivery_reservation.join()\r\n        }\r\n        pay.join()\r\n      }\r\n\r\n      log.info(\"(1)\")\r\n      order.join()\r\n      log.info(\"(2)\")\r\n    }\r\n\r\n    job.join()\r\n  }\r\n}\n위 코드의 결과는 아래와 같습니다. 원했던 결과인 주문 완료 → 결제 완료 → 배송 예약 완료 를 정상적으로 잘 만들어 냈음을 알 수 있습니다.\n12:08:16.478 [DefaultDispatcher-worker-1] INFO io.chagchagchag.demo.kotlin_coroutine.helper.LoggingObject -- (1)\r\n12:08:17.491 [DefaultDispatcher-worker-1] INFO io.chagchagchag.demo.kotlin_coroutine.helper.LoggingObject -- 주문 완료\r\n12:08:18.496 [DefaultDispatcher-worker-1] INFO io.chagchagchag.demo.kotlin_coroutine.helper.LoggingObject -- 결제 완료\r\n12:08:19.511 [DefaultDispatcher-worker-2] INFO io.chagchagchag.demo.kotlin_coroutine.helper.LoggingObject -- 배송 예약 완료\r\n12:08:19.513 [DefaultDispatcher-worker-1] INFO io.chagchagchag.demo.kotlin_coroutine.helper.LoggingObject -- (2)\r\n\r\nProcess finished with exit code 0\n이런 코드를 어떻게 단순화할 수 있을 까요?","원하는-특정-launch-코드-들의-연산을-coroutinescope-로-감싸기#원하는 특정 launch 코드 들의 연산을 coroutineScope 로 감싸기":"첫번째 방법은 순서대로 수행되어야 하는 각각의 launch{} 코드 들을 coroutineScope{...} 빌더 함수 내에서 실행하는 방식입니다.\npackage io.chagchagchag.demo.kotlin_coroutine.structured_concurrency\r\n\r\nimport io.chagchagchag.demo.kotlin_coroutine.helper.logger\r\nimport kotlinx.coroutines.*\r\nimport kotlin.coroutines.EmptyCoroutineContext\r\n\r\nfun main(){\r\n  val log = logger()\r\n\r\n  runBlocking {\r\n    val job = CoroutineScope(EmptyCoroutineContext).launch {\r\n      log.info(\"(1)\")\r\n      coroutineScope {\r\n        launch {\r\n          delay(1000)\r\n          log.info(\"주문 완료\")\r\n        }\r\n\r\n        launch {\r\n          delay(1000)\r\n          log.info(\"결제 완료\")\r\n        }\r\n\r\n        launch {\r\n          delay(1000)\r\n          log.info(\"배송 예약 완료\")\r\n        }\r\n      }\r\n      log.info(\"(2)\")\r\n    }\r\n    job.join()\r\n  }\r\n}\n출력결과는 원했던 결과인 주문 완료 → 결제 완료 → 배송 예약 완료 를 정상적으로 잘 만들어 냈음을 알 수 있습니다.coroutineScope 내에서 실행되는 자식 스코프 들은 coroutineScope 빌더 함수 내의 부모스코프가 각 자식 스코프들의 라이프사이클을 관리하고 확인하면서 각각의 자식 coroutine 들이 동기적으로 동작되게끔 관리합니다. 즉, coroutineScope 빌더 함수 내에서는 여러개의 코루틴 스코프가 있더라도 각각의 코루틴 스코프는 동기연산을 하듯 순서대로 동작합니다.\n12:15:59.359 [DefaultDispatcher-worker-2] INFO io.chagchagchag.demo.kotlin_coroutine.helper.LoggingObject -- (1)\r\n12:16:00.381 [DefaultDispatcher-worker-2] INFO io.chagchagchag.demo.kotlin_coroutine.helper.LoggingObject -- 주문 완료\r\n12:16:00.381 [DefaultDispatcher-worker-1] INFO io.chagchagchag.demo.kotlin_coroutine.helper.LoggingObject -- 결제 완료\r\n12:16:00.395 [DefaultDispatcher-worker-2] INFO io.chagchagchag.demo.kotlin_coroutine.helper.LoggingObject -- 배송 예약 완료\r\n12:16:00.395 [DefaultDispatcher-worker-2] INFO io.chagchagchag.demo.kotlin_coroutine.helper.LoggingObject -- (2)\r\n\r\nProcess finished with exit code 0","eg-withcontext#e.g. withContext":"","eg-1-context-공유-여부-확인#e.g 1. context 공유 여부 확인":"package io.chagchagchag.demo.kotlin_coroutine.structured_concurrency\r\n\r\nimport io.chagchagchag.demo.kotlin_coroutine.helper.logger\r\nimport kotlinx.coroutines.*\r\n\r\nfun main(){\r\n  val log = logger()\r\n\r\n  runBlocking {\r\n    val job = CoroutineScope(Dispatchers.Default).launch {\r\n      log.info(\"(before) 부모 코루틴 컨텍스트 : ${this.coroutineContext}\")\r\n\r\n      withContext(Dispatchers.IO){\r\n        log.info(\"withContext 컨텍스트 : ${this.coroutineContext}\")\r\n      }\r\n\r\n      log.info(\"(after) 부모 코루틴 컨텍스트 : ${this.coroutineContext}\")\r\n    }\r\n\r\n    job.join()\r\n  }\r\n}\n출력결과를 살펴보면, withContext() 가 사용하는 컨텍스트는 부모 코루틴 컨텍스트는 전혀 다르다는 것을 알 수 있습니다.출력결과\n13:49:45.660 [DefaultDispatcher-worker-1] INFO io.chagchagchag.demo.kotlin_coroutine.helper.LoggingObject -- (before) 부모 코루틴 컨텍스트 : [StandaloneCoroutine{Active}@3b805dfa, Dispatchers.Default]\r\n13:49:45.666 [DefaultDispatcher-worker-1] INFO io.chagchagchag.demo.kotlin_coroutine.helper.LoggingObject -- withContext 컨텍스트 : [DispatchedCoroutine{Active}@58c189ea, Dispatchers.IO]\r\n13:49:45.667 [DefaultDispatcher-worker-3] INFO io.chagchagchag.demo.kotlin_coroutine.helper.LoggingObject -- (after) 부모 코루틴 컨텍스트 : [StandaloneCoroutine{Active}@3b805dfa, Dispatchers.Default]\r\n\r\nProcess finished with exit code 0","eg-2-비동기-코드-동기연산-예제#e.g 2. 비동기 코드 동기연산 예제":"package io.chagchagchag.demo.kotlin_coroutine.structured_concurrency\r\n\r\nimport io.chagchagchag.demo.kotlin_coroutine.helper.logger\r\nimport kotlinx.coroutines.*\r\nimport kotlin.coroutines.EmptyCoroutineContext\r\n\r\nfun main(){\r\n  val log = logger()\r\n\r\n  runBlocking {\r\n    val job = CoroutineScope(EmptyCoroutineContext).launch {\r\n      val sum = sumCart2()\r\n      log.info(\"(1)\")\r\n      log.info(\"cartSum = $sum\")\r\n      log.info(\"(2)\")\r\n      assert(sum == 5000 + 7000 + 3000)\r\n    }\r\n\r\n    job.join()\r\n  }\r\n}\r\n\r\nsuspend fun sumCart2() : Int{\r\n  return withContext(Dispatchers.IO){\r\n    val applePrice = async {\r\n      delay(1000)\r\n      5000\r\n    }\r\n    val bananaPrice = async {\r\n      delay(1000)\r\n      7000\r\n    }\r\n    val carrotPrice = async {\r\n      delay(1000)\r\n      3000\r\n    }\r\n    applePrice.await() + bananaPrice.await() + carrotPrice.await()\r\n  }\r\n}\n확인해보면, 각각의 async 를 수행한 후에 합산이 정상적으로 잘 이루어짐을 확인 가능합니다.출력결과\n14:00:51.869 [DefaultDispatcher-worker-2] INFO io.chagchagchag.demo.kotlin_coroutine.helper.LoggingObject -- (1)\r\n14:00:51.874 [DefaultDispatcher-worker-2] INFO io.chagchagchag.demo.kotlin_coroutine.helper.LoggingObject -- cartSum = 15000\r\n14:00:51.875 [DefaultDispatcher-worker-2] INFO io.chagchagchag.demo.kotlin_coroutine.helper.LoggingObject -- (2)\r\n\r\nProcess finished with exit code 0"}},"/coroutine-scope-and-structured-concurrency/what-is-coroutine-scope":{"title":"What Is Coroutine Scope","data":{"coroutinescope#CoroutineScope":"CoroutineScope 는 Coroutine 의 Scope 를 정의하는 용도의 타입이며 interface 로 선언되어 있습니다.structured concurrency 라고 해서 중첩된 Coroutine Scope 를 가질 수도 있는데 여기에 대해서는 이 문서가 아닌 별도의 문서에서 정리하겠습니다.CoroutineScope 를 만들때에는 보통 Coroutine Builder 라고 불리는 함수를 사용하는데 대부분 CoroutineScope interface 에 확장함수로 추가된 함수이며 withContext(), launch(), async() 등이 있습니다. withContext(), launch(), async() 확장함수의 정의는 Builders.common.kt 에 정의되어 있습니다.","uml---coroutinescope-와-coroutinecontext-의-연관관계#UML - CoroutineScope 와 CoroutineContext 의 연관관계":"CoroutineScope 는 내부에 CoroutineContext 를 잡고 움직입니다. 당연하게도, 스코프를 관리하는 데에 있어서 Context(문맥)이 필요하기 때문입니다. 그리고 CorutineScope 는 interface 이기에 직접 객체 생성이 불가능한데, 실제로는 구체타입인 ContextScope 객체로 생성하며, ContextScope 객체를 생성하는 함수는 CoroutineScope.kt 내에 CoroutineScope(context) 라는 함수에서 수행합니다.코틀린은 특이하게도 interface 안에서 생성자처럼 보일 수 있는 함수들을 선언하고 특정 기본 구현체를 생성하는 객체 생성 함수들을 interface 내에서 제공하도록 구현하는게 관례처럼 되어 있는 라이브러리들이 많습니다.이렇게 ContextScope 객체를 만들 때에는 Job 인스턴스가 필요합니다. 당연하게도 코루틴을 구동시키려면 Job 이 필요하겠죠. 이 때 Job 인스턴스는 Job.kt 파일 내의 Job(CoroutineContext) 함수를 통해 생성합니다. 실제로 내부적으로는 콜 스택을 한 번 더 타서 JobSupport.kt 내의 JobImpl(parent) 라는 함수를 통해 실질적인 객체를 생성합니다.이렇게 생성한 Job 객체는 이미 CoroutineScope 내에 존재하는 coroutineContext 객체에 병합해둡니다. 여기까지가 CoroutineScope 객체가 생성하는 동안 내부적으로 벌어지는 일 입니다.\n필요한 내용만 요약해보면 이렇습니다.\nCoroutineScope 내에는 CoroutineContext 정보가 필요한데, 따라서 CoroutineContext 타입에는 항상 멤버 필드 coroutineContext 가 있다.\nCoroutineScope 는 interface 이기에 구체타입으로 객체를 생성해야 하는데, 내부 구현상으로 기본적으로는 ContextScope 객체를 이용해 CoroutineScope 타입이 생성된다.\nContextScope 라는 구체 타입의 CoroutineScope 가 생성될 때 Job 객체를 주입받아서 이것을 멤버 필드인 coroutineContext 에 초기화 한다. Job 객체 역시 상위 타입이 CoroutineContext 이기에 coroutineContext 에 저장하는 것이 가능하다.","coroutinescope-빌더-함수들#CoroutineScope 빌더 함수들":"코틀린의 kotlinx-coroutines-core 에서는 launch, async,  withContext, runBlocking 등과 같은 함수들을 보통 코루틴 빌더 함수라고 부릅니다. 복잡한 CoroutineContext 생성 및 기타 설정들을 직접 작성하지 않고 라이브러리에 내장된 빌더 성격의 함수를 사용하도록 유도한 것입니다.잘알려진 코루틴 빌더 함수들은 아래와 같습니다.\nwithContext : 코루틴 컨텍스트를 변경하는 함수입니다. 다른 스레드에서 코드를 실행하거나, 특정 디스패처에 작업을 보내는 것이 가능합니다.\ndelay : 일정 시간 동안 코루틴을 일시 중단하는 함수입니다. 주로 테스트나 간단한 딜레이를 구현할 때 사용됩니다.\nasync: 비동기 작업의 결과를 반환하는 코루틴을 생성합니다. 생성된 코루틴은 Deferred 객체를 반환하며, 이를 통해 결과를 가져올 수 있습니다.\nawait: Deferred 객체의 결과를 기다리는 함수로, async 함수로 생성된 Deferred 객체의 결과를 가져올 때 사용됩니다.\nlaunch: 백그라운드에서 비동기적으로 새로운 코루틴을 실행하는 함수로, 반환 값이 없는 Fire-and-forget 스타일의 코루틴을 생성합니다.\nrunBlocking: 새로운 블록 내에서 코루틴을 실행하는 함수로, 주로 메인 함수나 테스트 코드에서 사용되며, 코루틴을 기다리는 동안 블로킹을 유지합니다.\ncoroutineScope: 지정된 블록 내에서 새로운 코루틴 스코프를 생성하는 함수로, 지정된 블록 내의 코루틴이 완료될 때까지 대기합니다.\nselect: 여러 개의 중단 가능한 조건을 동시에 처리할 수 있는 함수로, 먼저 발생하는 이벤트를 처리하고 나머지는 무시합니다.\nsupervisorScope: 자식 코루틴이 실패하더라도 부모 코루틴이 중단되지 않도록 하는 슈퍼바이저 스코프를 생성하는 함수로, 자식 코루틴의 실패를 격리합니다.\n이전문서인 suspend 함수의 개념을 다룬 문서에서 이야기했듯, CoroutineScope 빌더 함수들은 마지막 인자가 람다입니다. 코틀린에서는 마지막 인자가 람다일 경우 함수 인자를 생략하고 launch{...} 처럼 표현 가능합니다.그래서 대부분의 launch, async 같은 함수들이 함수 인자도 없이 {...} 을 사용하는 것입니다.","coroutine-스코프-생성#Coroutine 스코프 생성":"코루틴 스코프는 launch, await , coroutineScope 등과 같은 코루틴 빌더를 이용해서 생성할 수도 있겠지만 단순하게 CoroutineScope.kt 내에 정의된 CoroutineScope 라는 함수를 이용해서도 생성할 수 있습니다.\npackage io.chagchagchag.demo.kotlin_coroutine.coroutine_scope\r\n\r\nimport io.chagchagchag.demo.kotlin_coroutine.helper.logger\r\nimport kotlinx.coroutines.CoroutineScope\r\nimport kotlin.coroutines.EmptyCoroutineContext\r\n\r\nfun main(){\r\n  val log = logger()\r\n\r\n  val coroutineScope = CoroutineScope(EmptyCoroutineContext)\r\n\r\n  log.info(\"방금 생성한 코루틴 스코프 = $coroutineScope\")\r\n  log.info(\"코루틴 스코프 클래스 = ${coroutineScope.javaClass.simpleName}\")\r\n}\r\n출력결과\n08:20:37.108 [main] INFO io...helper.LoggingObject -- 방금 생성한 코루틴 스코프 = CoroutineScope(coroutineContext=JobImpl{Active}@6615435c)\r\n08:20:37.113 [main] INFO io...helper.LoggingObject -- 코루틴 스코프 클래스 = ContextScope\r\n\r\nProcess finished with exit code 0","launch#launch":"launch{...} 는 CoroutineScope 를 반환합니다. 그리고 Java 의 CompletableFuture 처럼 join() 함수를 사용할 수 있습니다.\npackage io.chagchagchag.demo.kotlin_coroutine.coroutine_scope\r\n\r\nimport io.chagchagchag.demo.kotlin_coroutine.helper.logger\r\nimport kotlinx.coroutines.*\r\nimport kotlin.coroutines.EmptyCoroutineContext\r\n\r\nfun main(){\r\n  val log = logger()\r\n\r\n  runBlocking {\r\n    val scope = CoroutineScope(EmptyCoroutineContext)\r\n    log.info(\"scope 에 생성된 Job = ${scope.coroutineContext[Job]}\")\r\n\r\n    log.info(\"launchedJob 을 시작하겠습니다.\")\r\n    \r\n    val launchedJob = scope.launch {\r\n      delay(1000)\r\n      val currentContext = this.coroutineContext\r\n      val scopeClassName = this.javaClass.simpleName\r\n      val currentJob = this.coroutineContext[Job]\r\n      log.info(\"this.coroutineContext = $currentContext\")\r\n      log.info(\"class name = $scopeClassName\")\r\n      log.info(\"현재 Job 의 부모(parent) = ${currentJob?.parent}\")\r\n    }\r\n\r\n    launchedJob.join()\r\n    log.info(\"launchedJob 을 종료합니다.\")\r\n  }\r\n\r\n}\r\nlaunch 를 통해 CoroutineScope 를 만들고 이 CoroutineScope 가 중지했다가 재개하는 함수의 예제입니다. 부가적으로 CoroutineScope 내에는 무엇이 있는지 확인하기 위해 아래 요소들을 출력해봅니다.\nthis.coroutineContext\nthis.javaClass.simpleName\nthis.coroutineContext[Job]\n출력결과\n08:42:26.917 [main] INFO io...helper.LoggingObject -- scope 에 생성된 Job = JobImpl{Active}@6f1fba17\r\n08:42:26.956 [main] INFO io...helper.LoggingObject -- launchedJob 을 시작하겠습니다.\r\n08:42:27.973 [DefaultDispatcher-worker-1] INFO io...helper.LoggingObject -- this.coroutineContext = [StandaloneCoroutine{Active}@41f230d0, Dispatchers.Default]\r\n08:42:27.973 [DefaultDispatcher-worker-1] INFO io...helper.LoggingObject -- class name = StandaloneCoroutine\r\n08:42:27.973 [DefaultDispatcher-worker-1] INFO io...helper.LoggingObject -- 현재 Job 의 부모(parent) = JobImpl{Active}@6f1fba17\r\n08:42:27.974 [main] INFO io...helper.LoggingObject -- launchedJob 을 종료합니다.","async#async":"참고 :\nCoroutineScope.async()\nDeferred\nAbstractCoroutine\nasync{...} 는 Deferred 객체를 반환합니다. 이 Deferred 객체는 Job interface 를 extends 하는 interface 입니다. 그리고 async{...} 빌더의 내부를 살펴보면 아래와 같이 LazyDeferredCoroutine 또는 DeferredCoroutine 이라는 구체 타입의 인스턴스를 리턴합니다.Builders.common.kt\npublic fun <T> CoroutineScope.async(\r\n    context: CoroutineContext = EmptyCoroutineContext,\r\n    start: CoroutineStart = CoroutineStart.DEFAULT,\r\n    block: suspend CoroutineScope.() -> T\r\n): Deferred<T> {\r\n    val newContext = newCoroutineContext(context)\r\n    val coroutine = if (start.isLazy)\r\n        LazyDeferredCoroutine(newContext, block) else\r\n        DeferredCoroutine<T>(newContext, active = true)\r\n    coroutine.start(start, coroutine, block)\r\n    return coroutine\r\n}\n이 중 DeferredCoroutine 의 상속관계를 찾아서 위로 올라가면 차례로 AbstractCoroutine 클래스, CoroutineScope 클래스를 만나게 됩니다.즉, async{...} 가 반환하는 Deferred 객체는 CoroutineScope 로 일반화해서 처리 가능하다는 의미입니다.아래는 launch{...} 라는 코루틴 빌더의 예제입니다.\npackage io.chagchagchag.demo.kotlin_coroutine.coroutine_scope\r\n\r\nimport io.chagchagchag.demo.kotlin_coroutine.helper.logger\r\nimport kotlinx.coroutines.*\r\nimport kotlin.coroutines.EmptyCoroutineContext\r\n\r\nfun main(){\r\n  val log = logger()\r\n\r\n  runBlocking {\r\n    val scope = CoroutineScope(EmptyCoroutineContext)\r\n    log.info(\"현재 Job = ${scope.coroutineContext[Job]}\")\r\n\r\n    log.info(\"시작\")\r\n    val deferred = scope.async {\r\n      delay(1000)\r\n      val currentContext = this.coroutineContext\r\n      val currentContextClassName = this.javaClass.simpleName\r\n      val whatIsParent = this.coroutineContext[Job]?.parent\r\n\r\n      log.info(\"현재 코루틴 컨텍스트 = $currentContext\")\r\n      log.info(\"현재 코루틴 컨텍스트의 클래스명 = $currentContextClassName\")\r\n      log.info(\"현재 Job 의 부모 = $whatIsParent\")\r\n\r\n      25000\r\n    }\r\n\r\n    log.info(\"코루틴이 반환한 값 = ${deferred.await()}\")\r\n    log.info(\"끝\")\r\n  }\r\n}\n마치 javascript 의 async, await 을 사용하는 것과 비슷한 코드입니다.출력결과를 확인해보면 async 가 생성한 코루틴 컨텍스트는 DeferredCoroutine 입니다. 자신을 생성한 부모 스코프를 참조할 수 있는지 확인하기 위해 this.coroutineContext[Job]?.parent 을 출력해보면 정확하게 출력이 됩니다. 코루틴 컨텍스트는 자신의 부모스코프가 무엇인지 알수 있다는 사실을 알 수 있습니다. 이것은 자신이 호출된 바로 전 단계의 스코프를 참조할 수 있다는 의미이기 때문에, 조금 복잡한 호출구조의 비동기 프로그래밍을 할 때 중요한 개념이 됩니다.중요한 점은 async(), await() 을 하는 동안 프로그램이 블로킹 상태가 아니라는 점입니다. await() 을 하는 동안 코틀린은 내부적으로 다른 코루틴을 조율하면서 실행시키고 있고 async 내부의 작업이 끝나는 순간 await() 을 하는 작업을 완료하게 됩니다.\n출력결과\n09:03:48.916 [main] INFO io...helper.LoggingObject -- 현재 Job = JobImpl{Active}@6f1fba17\r\n09:03:48.925 [main] INFO io...helper.LoggingObject -- 시작\r\n09:03:49.971 [DefaultDispatcher-worker-1] INFO io...helper.LoggingObject -- 현재 코루틴 컨텍스트 = [DeferredCoroutine{Active}@1b2786cb, Dispatchers.Default]\r\n09:03:49.971 [DefaultDispatcher-worker-1] INFO io...helper.LoggingObject -- 현재 코루틴 컨텍스트의 클래스명 = DeferredCoroutine\r\n09:03:49.971 [DefaultDispatcher-worker-1] INFO io...helper.LoggingObject -- 현재 Job 의 부모 = JobImpl{Active}@6f1fba17\r\n09:03:49.974 [main] INFO io...helper.LoggingObject -- 코루틴이 반환한 값 = 25000\r\n09:03:49.975 [main] INFO io...helper.LoggingObject -- 끝\r\n\r\nProcess finished with exit code 0","async-코루틴-빌더-내부-살펴보기#async 코루틴 빌더 내부 살펴보기":"TODO : 다른 작업이 더 우선순위가 높다고 판단해 잠시 스킵"}},"/":{"title":"Introduction","data":{}},"/suspend-and-fsm-cps/fsm-and-cps":{"title":"Fsm and Cps","data":{"fsm-cps#FSM, CPS":""}},"/coroutine-useful-case/intro":{"title":"Intro","data":{}},"/kotlin-basic/intro":{"title":"Intro","data":{}},"/error-handler-and-job-cancelling/intro":{"title":"Intro","data":{}},"/suspend-and-fsm-cps/to-coroutine":{"title":"코루틴 코드로 바꿔보면","data":{}},"/flow/intro":{"title":"Intro","data":{}},"/suspend-and-fsm-cps/what-is-suspend-function":{"title":"What Is Suspend Function","data":{"코루틴의-개념-suspend-함수#코루틴의 개념, suspend 함수":"","코틀린의-코루틴#코틀린의 코루틴":"코틀린 코루틴은 비동기 프로그래밍을 위한 강력한 도구입니다.코루틴은 코드의 일부를 일시 중단하고 나중에 재개할 수 있는 경량 스레드로 볼 수 있습니다. 코루틴은 스레드 하나에서 여러 개의 코루틴으로 나눠서 병렬로 수행할 수 있습니다. 즉, 스레드에서 수행되는 개별적인 작업의 단위로 각각의 작업을 수행하는 것을 코루틴이라고 합니다. 코루틴은 코틀린에만 존재하는 것이 아닙니다. 이미 오래전에 1990년대부터 존재하던 개념이고,  c, c++, javascript, go 등 현존하는 모든 프로그래밍 언어에 존재하지만, Kotlin 에는 도입되었지만 아직 Java 에는 도입되지 않았습니다.","suspend-함수#suspend 함수":"suspend 함수는 코루틴을 구현하는 데 중요한 역할을 합니다. suspend 함수를 선언하려면  suspend 라는 키워드를 함수 앞에 붙여서 선언하면 suspend 함수가 됩니다. 이렇게 하면 컴파일러가 suspend 가 붙은 함수를 코루틴 내에서 사용할 수 있는 함수로 인식합니다. 코루틴 내에서 일시 중단이 가능한 모든 작업은 반드시 suspend 함수에서 수행되어야 합니다.","suspend-함수는-뭐고-코루틴은-뭔가요#suspend 함수는 뭐고 코루틴은 뭔가요?":"코틀린에서는 suspend 키워드를 붙인 함수가 코루틴으로 실행됩니다. 코루틴은 일시 중단할 수 있고 재개할 수 있는 개념이며 스레드보다 작은 단위의 개념입니다. 코루틴은 코루틴 내에서 여러 개의 코루틴이 분기할 수 있는데 이때 여러 개의 개별 코루틴 컨텍스트로 동작하거나 개발자가 직접 지정한 코루틴 컨텍스트 내에서 함께 동작하거나 하는 것을 지정하는 것이 가능합니다. 이런 코루틴을 사용하기 위해서는 suspend 키워드가 붙어 있어야만 가능하며 suspend 키워드는 함수에 붙일 수 있습니다. suspend 함수는 코틀린 언어가 실행될 수 있는 환경인 JVM 에 의해 실행됩니다.코틀린이 기본으로 제공하는 라이브러리 들 중 대표적인 suspend 기반의 함수들에는 launch, async , runBlocking, withContext 등이 있는데 이들 모두를 코루틴 빌더라고 이야기합니다.launch 함수는 반환값이 없는 Fire-and-forget 스타일의 코루틴을 생성하고 실행하며, async 함수는 비동기 작업의 결과를 리턴하는 코루틴을 만들어냅니다.코루틴은 멀티 스레딩과 함께 사용되어 병렬 처리를 가능하게 하지만, 코루틴은 기본적으로 단일 스레드에서 실행됩니다. 따라서 코루틴은 비동기 작업을 보다 간편하게 처리할 수 있는 동시성 프로그래밍 모델을 제공합니다.코틀린의 코루틴은 비동기적인 코드를 작성하고 관리하는 데 매우 유용한 도구이며, 코틀린 표준 라이브러리에 포함되어 있어 바로 사용할 수 있습니다.","코틀린에서-기본적으로-제공하는-suspend-함수들#코틀린에서 기본적으로 제공하는 suspend 함수들":"코틀린에서 기본적으로 제공하는 대표적인 suspend 함수는 kotlinx.coroutines패키지 내의 Builders.common.kt에 있으며 launch, async, withContext 등이 있습니다.","async-launch-withcontext-는-coroutinescope-의-확장함수#async, launch, withContext 는 CoroutineScope 의 확장함수":"async, launch, withContext 함수는 suspend 함수라고 부르기도 합니다. 한가지 알아두고 넘어가야 할 것은 async, launch, withContext 는 CoroutineScope 안에서 동작한다는 점입니다. 그리고 async, launch,withContext 는 CoroutineScope 의 확장함수로 선언되어 있습니다.","suspend-함수의-주요-특징#suspend 함수의 주요 특징":"suspend 함수의 주요 특징은 아래와 같습니다.\nsuspend 함수는 일시 중단할 수 있는 함수입니다.\nsuspend 가 적용된 함수가 실행되는 동안 일시 중단될 경우, suspend 를 실행하는 동안 내부적으로는 다른 작업을 수행하거나 대기하게 됩니다. 즉, 논블로킹 기반으로 동작합니다. suspend 함수를 호출할 때에는 이 suspend 함수를 호출한 코루틴이 일시 중단됩니다.\nsuspend 함수를 사용하면 비동기적인 작업을 수행하는 동안 UI를 블로킹하지 않고도 작업을 수행할 수 있습니다.\n예를 들어 네트워크 호출이나 파일 I/O와 같은 작업을 수행할 때 suspend 함수를 사용하여 코루틴을 일시 중단하고 나중에 결과를 받아서 처리할 수 있습니다.\nsuspend 가 적용된 함수는 suspend 가 붙은 함수에서만 호출이 가능합니다.\nSpring Webflux 는 Controller 에 suspend 함수를 지원합니다. 따라서 Controller 내에서는 suspend 함수를 실행이 가능합니다.\nsuspend 가 적용되지 않은 함수이지만 라이브러리 함수여서 수정이 불가능하고 호출역시 불가능할 경우가 있습니다. 이 경우 아래의 두 방식으로 일반함수내에서 suspend 함수를 감싸서 실행하는 방식으로 사용이 가능합니다.\nkotlin-coroutines-reactor 의 mono 함수 내부에서 suspend 함수를 실행\nCoroutineScope(CoroutineDispatcher).future { ... } 를 사용하는 방식","suspend-기반의-kotlin-내장-함수들#suspend 기반의 kotlin 내장 함수들":"async, launch, withContext 말고도 코틀린의 kotlinx-coroutines-core 에서 제공하는 suspend 가 적용된 함수들은 많습니다. kotlin 라이브러리에서 제공하는 대표적으로 잘 알려진 suspend 함수들은 아래와 같습니다.\nwithContext : 코루틴 컨텍스트를 변경하는 함수입니다. 다른 스레드에서 코드를 실행하거나, 특정 디스패처에 작업을 보내는 것이 가능합니다.\ndelay : 일정 시간 동안 코루틴을 일시 중단하는 함수입니다. 주로 테스트나 간단한 딜레이를 구현할 때 사용됩니다.\nasync: 비동기 작업의 결과를 반환하는 코루틴을 생성합니다. 생성된 코루틴은 Deferred 객체를 반환하며, 이를 통해 결과를 가져올 수 있습니다.\nawait: Deferred 객체의 결과를 기다리는 함수로, async 함수로 생성된 Deferred 객체의 결과를 가져올 때 사용됩니다.\nlaunch: 백그라운드에서 비동기적으로 새로운 코루틴을 실행하는 함수로, 반환 값이 없는 Fire-and-forget 스타일의 코루틴을 생성합니다.\nrunBlocking: 새로운 블록 내에서 코루틴을 실행하는 함수로, 주로 메인 함수나 테스트 코드에서 사용되며, 코루틴을 기다리는 동안 블로킹을 유지합니다.\ncoroutineScope: 지정된 블록 내에서 새로운 코루틴 스코프를 생성하는 함수로, 지정된 블록 내의 코루틴이 완료될 때까지 대기합니다.\nselect: 여러 개의 중단 가능한 조건을 동시에 처리할 수 있는 함수로, 먼저 발생하는 이벤트를 처리하고 나머지는 무시합니다.\nsupervisorScope: 자식 코루틴이 실패하더라도 부모 코루틴이 중단되지 않도록 하는 슈퍼바이저 스코프를 생성하는 함수로, 자식 코루틴의 실패를 격리합니다.","suspend-함수는-어디에서-실행되나요#suspend 함수는 어디에서 실행되나요?":"중단된 suspend 함수는 재개될 때 CoroutineDispatcher 가 어느 스레드에서 실행할지 결정합니다.CoroutineDispatcher 역시 CoroutineContext 의 일종입니다. CoroutineContext 에는 CoroutineName, Job, ThreadLocalElement, ReactorContext 등이 있습니다.CoroutineContext 의 개념과 원리, 예제, CoroutineDispatcher 의 개념, 종류 등의 개념은 이 블로그 내에서 별도의 카테고리에 분류해서 정리하고 있습니다. 정리가 완료되면 링크를 추가하겠습니다.\nTOOD : 링크 추가\nsuspend 함수를 통해 만들어진 코루틴은 하나의 스레드에서 실행되다가 중지된 후 다른 스레드에서 이어서 실행할 수 있습니다. 비동기연산을 논 블로킹하게 수행하기 때문입니다.\nTODO : 그림 추가","suspend-함수는-비동기인가요--동기-연산인가요#suspend 함수는 비동기인가요 ? 동기 연산인가요?":"suspend 함수는 비동기 연산으로 수행되게끔 할 수도 있고 비동기 코드인데 동기연산처럼 수행하게끔 await() 등의 함수를 사용해서 동기코드처럼 사용하는 것도 가능합니다. 다만 이렇게 비동기 코드를 동기 코드 처럼 순차적으로 처리되는 식으로 작성한 코드를 흔히 블로킹 방식 코드로 착각하게 된다는 점을 주의해야 합니다. 비동기 적인 연산을 하는 suspend 함수를 동기 코드 처럼 동작하도록 await() 함수 등을 사용할 때, await() 함수에 대한 IO Bound 작업이 끝날 때 까지 뒷단에서 코루틴 디스패처는 다른 작업들을 관리해서 수행시키고 조율시킵니다.","fsm-cps-suspend-함수#FSM, CPS, suspend 함수":"suspend 가 붙은 함수를 suspend 함수 없이 내부적인 구현을 구현하면 결국은 FSM(Finite State Machine), CPS(Continuation Passing Style) 을 기반으로 한 재귀 호출구문으로 이뤄지게 됩니다. FSM 이라는 것은 유한 상태 기계라는 의미인데 일종의 label 을 통해 상태를 인식해서 다음 상태로 넘어가게 해주는 것을 의미하고 CPS 는 다음 상태로 지속이 가능한 객체인 Continuation 을 넘겨주는 방식을 의미합니다. Continuation 객체 내에는 주로 데이터를 처리하거나 바인딩하기 위한 구조체 같은 데이터가 포함됩니다.\n더 자세한 내용은 FSM, CPS 문서에 따로 정리해두겠습니다.","suspend-함수-예제#suspend 함수 예제":"","suspend-함수는-일시-중단할-수-있는-함수#suspend 함수는 일시 중단할 수 있는 함수":"suspend 함수는 일시 중단하는 함수입니다. 아래는 그 코드입니다.\n그런데 이렇게 일시중단한다고 해서 코드 자체가 블로킹 상태가 되는 것이 아닙니다. 블로킹이라고 하는 것은 다른 작업을 수행하지 못하는 상태를 의미하는데, suspend 함수로 일시 중단 상태가 되었을 때 뒷단에서는 코루틴 디스패처 안에 쌓여있는 다른 작업을 수행하면서 suspend 함수의 동작이 끝나기를 기다립니다.이렇게 하는 이유는 현대적인 애플리케이션들이 계산작업으로 인한  CPU 점유 보다는 IO로 인한 응답대기를 하는 것으로 인한 CPU 점유가 더 높기 때문입니다. IO의 응답이 오기 전까지 스레드 하나를 차지하고 있는 것은 낭비이기 때문에 하나의 스레드 내에서 여러 개의 코루틴으로 분리하고 하나의 코루틴이 IO 작업을 완료하기 전까지 다른 코루틴을 코루틴 디스패처가 분배하면서 작업을 합니다.저 역시도 코루틴의 suspend 함수를 학습하면서 위의 코드가 블로킹이라고 착각했었고 코틀린을 배우느라 알게된 패캠 강사님도 위의 코드를 처음에는 블로킹 코드로 착각했다고 하셨었습니다. 많은 사람들이 착각하는 부분입니다. 다른 일을 오랫동안 하다가 다시 코틀린 코루틴을 다룰 때도 까먹었다가 다시 생각날 수도 있는 개념이기에 코루틴은 블로킹이 아니라 논블로킹이고 작업을 중단해두었지만, 내부적으로는 다른 작업을 처리하게끔 해둔 상태에서 중단한 것이라고 개념을 주의해서 기억해둬야 할 필요가 있습니다.","suspend-함수는-논블로킹-기반의-비동기-연산을-수행#suspend 함수는 논블로킹 기반의 비동기 연산을 수행":"","suspend-함수는-suspend-함수에서만-호출-가능#suspend 함수는 suspend 함수에서만 호출 가능":"","spring-webflux-의-에서는-suspend-를-지원#Spring Webflux 의 에서는 suspend 를 지원":"Spring Webflux 는 Controller 에 suspend 함수를 지원합니다. 따라서 아래 코드와 같이 Controller 내에서는 suspend 함수를 실행이 가능합니다.\npackage io.chagchagchag.demo.kotlin_coroutine\r\n\r\n// ...\r\n\r\n@RestController\r\n@RequestMapping(\"/healthcheck\")\r\nclass HealthCheckController {\r\n\r\n  private suspend fun ok(): String = \"OK\"\r\n\r\n  @GetMapping(\"/ready\")\r\n  suspend fun ready(): String{\r\n    return ok()\r\n  }\r\n}","mono-completablefuture-를-반환하는-라이브러리-함수가-suspend-함수가-아닐-경우#Mono, CompletableFuture 를 반환하는 라이브러리 함수가 suspend 함수가 아닐 경우":"kotlin-coroutines-reactor 의 mono 함수 내부에서 suspend 함수를 실행\nCoroutineScope(CoroutineDispatcher).future { ... } 를 사용하는 방식\nCoroutineScope(CoroutineDispatcher).future { ... }  내에서 suspend 함수를 실행하고, 반환되는 CompletableFuture를 thneAccept 등을 통해서 실행\nTODO : 그림 추가"}}}